// This file is auto-generated by @hey-api/openapi-ts

import {
  type Client,
  type Options as Options2,
  type TDataShape,
  urlSearchParamsBodySerializer,
} from './client';
import { client } from './client.gen';
import type {
  AcceptProposalData,
  AcceptProposalErrors,
  AcceptProposalResponses,
  AcknowledgeMemoData,
  AcknowledgeMemoErrors,
  AcknowledgeMemoResponses,
  AddDatabaseData,
  AddDatabaseErrors,
  AddDatabaseResponses,
  AddLinkedRepoData,
  AddLinkedRepoErrors,
  AddLinkedRepoResponses,
  AddMissionData,
  AddMissionErrors,
  AddMissionResponses,
  AddSessionData,
  AddSessionErrors,
  AddSessionResponses,
  AddTaskData,
  AddTaskErrors,
  AddTaskResponses,
  AnalyseVisualContentData,
  AnalyseVisualContentErrors,
  AnalyseVisualContentResponses,
  ArchiveSessionData,
  ArchiveSessionErrors,
  ArchiveSessionResponses,
  BatchResolveOcxpUrisData,
  BatchResolveOcxpUrisErrors,
  BatchResolveOcxpUrisResponses,
  BrowsePageData,
  BrowsePageErrors,
  BrowsePageResponses,
  BulkAcknowledgeMemosData,
  BulkAcknowledgeMemosErrors,
  BulkAcknowledgeMemosResponses,
  BulkCreateMemosData,
  BulkCreateMemosErrors,
  BulkCreateMemosResponses,
  BulkDeleteContentData,
  BulkDeleteContentErrors,
  BulkDeleteContentResponses,
  BulkDeleteMemosData,
  BulkDeleteMemosErrors,
  BulkDeleteMemosResponses,
  BulkMoveContentData,
  BulkMoveContentErrors,
  BulkMoveContentResponses,
  BulkReadContentData,
  BulkReadContentErrors,
  BulkReadContentResponses,
  BulkReadMemosData,
  BulkReadMemosErrors,
  BulkReadMemosResponses,
  BulkResolveMemosData,
  BulkResolveMemosErrors,
  BulkResolveMemosResponses,
  BulkUpdateTasksData,
  BulkUpdateTasksErrors,
  BulkUpdateTasksResponses,
  BulkWriteContentData,
  BulkWriteContentErrors,
  BulkWriteContentResponses,
  CapturePageScreenshotsData,
  CapturePageScreenshotsErrors,
  CapturePageScreenshotsResponses,
  CaptureScreenshotData,
  CaptureScreenshotErrors,
  CaptureScreenshotResponses,
  ComparePagesData,
  ComparePagesErrors,
  ComparePagesResponses,
  CreateDatabaseData,
  CreateDatabaseErrors,
  CreateDatabaseResponses,
  CreateFolderData,
  CreateFolderErrors,
  CreateFolderResponses,
  CreateMemoData,
  CreateMemoErrors,
  CreateMemoResponses,
  CreateMissionData,
  CreateMissionErrors,
  CreateMissionResponses,
  CreateProjectData,
  CreateProjectErrors,
  CreateProjectResponses,
  CreateSessionData,
  CreateSessionErrors,
  CreateSessionResponses,
  CreateWorkflowData,
  CreateWorkflowErrors,
  CreateWorkflowResponses,
  DeleteContentData,
  DeleteContentErrors,
  DeleteContentResponses,
  DeleteCredentialsData,
  DeleteCredentialsErrors,
  DeleteCredentialsResponses,
  DeleteDatabaseData,
  DeleteDatabaseErrors,
  DeleteDatabaseResponses,
  DeleteGithubTokenData,
  DeleteGithubTokenErrors,
  DeleteGithubTokenResponses,
  DeleteMemoData,
  DeleteMemoErrors,
  DeleteMemoResponses,
  DeleteMissionData,
  DeleteMissionErrors,
  DeleteMissionResponses,
  DeleteProjectData,
  DeleteProjectErrors,
  DeleteProjectResponses,
  DeleteRepoData,
  DeleteRepoErrors,
  DeleteRepoResponses,
  DeleteTaskData,
  DeleteTaskErrors,
  DeleteTaskResponses,
  DeleteWorkflowData,
  DeleteWorkflowErrors,
  DeleteWorkflowResponses,
  DiscoverContextData,
  DiscoverContextErrors,
  DiscoverContextResponses,
  DownloadMissionPackData,
  DownloadMissionPackErrors,
  DownloadMissionPackResponses,
  DownloadProjectPackData,
  DownloadProjectPackErrors,
  DownloadProjectPackResponses,
  DownloadRepositoryData,
  DownloadRepositoryErrors,
  DownloadRepositoryResponses,
  ExportCheckpointAsSopData,
  ExportCheckpointAsSopErrors,
  ExportCheckpointAsSopResponses,
  ExtractElementsData,
  ExtractElementsErrors,
  ExtractElementsResponses,
  ForkSessionData,
  ForkSessionErrors,
  ForkSessionResponses,
  GetAuthConfigData,
  GetAuthConfigResponses,
  GetCheckpointData,
  GetCheckpointErrors,
  GetCheckpointResponses,
  GetContentStatsData,
  GetContentStatsErrors,
  GetContentStatsResponses,
  GetContentTreeData,
  GetContentTreeErrors,
  GetContentTreeResponses,
  GetContentTypesData,
  GetContentTypesErrors,
  GetContentTypesResponses,
  GetContextReposData,
  GetContextReposErrors,
  GetContextReposResponses,
  GetCredentialsData,
  GetCredentialsErrors,
  GetCredentialsResponses,
  GetCurrentUserData,
  GetCurrentUserErrors,
  GetCurrentUserResponses,
  GetDatabaseData,
  GetDatabaseErrors,
  GetDatabaseOverviewData,
  GetDatabaseOverviewErrors,
  GetDatabaseOverviewResponses,
  GetDatabaseResponses,
  GetGithubTokenStatusData,
  GetGithubTokenStatusErrors,
  GetGithubTokenStatusResponses,
  GetMemoData,
  GetMemoErrors,
  GetMemoForSourceData,
  GetMemoForSourceErrors,
  GetMemoForSourceResponses,
  GetMemoResponses,
  GetMissionContextData,
  GetMissionContextErrors,
  GetMissionContextResponses,
  GetMissionData,
  GetMissionErrors,
  GetMissionResponses,
  GetProjectData,
  GetProjectDatabasesData,
  GetProjectDatabasesErrors,
  GetProjectDatabasesResponses,
  GetProjectErrors,
  GetProjectMemosData,
  GetProjectMemosErrors,
  GetProjectMemosResponses,
  GetProjectResponses,
  GetPrototypeChatData,
  GetPrototypeChatErrors,
  GetPrototypeChatResponses,
  GetProvenanceData,
  GetProvenanceErrors,
  GetProvenanceResponses,
  GetRepoCommitsData,
  GetRepoCommitsErrors,
  GetRepoCommitsResponses,
  GetRepoDownloadStatusData,
  GetRepoDownloadStatusErrors,
  GetRepoDownloadStatusResponses,
  GetSampleData,
  GetSampleErrors,
  GetSampleResponses,
  GetSchemaData,
  GetSchemaErrors,
  GetSchemaResponses,
  GetSessionMessagesData,
  GetSessionMessagesErrors,
  GetSessionMessagesResponses,
  GetStoredVersionsData,
  GetStoredVersionsErrors,
  GetStoredVersionsResponses,
  GetSyncStatusData,
  GetSyncStatusErrors,
  GetSyncStatusResponses,
  GetTaskData,
  GetTaskErrors,
  GetTaskResponses,
  GetWorkflowData,
  GetWorkflowErrors,
  GetWorkflowResponses,
  GithubCheckAccessData,
  GithubCheckAccessErrors,
  GithubCheckAccessResponses,
  GithubGetContentsData,
  GithubGetContentsErrors,
  GithubGetContentsResponses,
  GithubListBranchesData,
  GithubListBranchesErrors,
  GithubListBranchesResponses,
  HealthCheck2Data,
  HealthCheck2Responses,
  HealthCheckData,
  HealthCheckErrors,
  HealthCheckResponses,
  IgnoreMemoData,
  IgnoreMemoErrors,
  IgnoreMemoResponses,
  IngestDocumentsData,
  IngestDocumentsErrors,
  IngestDocumentsResponses,
  LinkPrototypeChatData,
  LinkPrototypeChatErrors,
  LinkPrototypeChatResponses,
  ListContentData,
  ListContentErrors,
  ListContentResponses,
  ListContextDatabasesData,
  ListContextDatabasesErrors,
  ListContextDatabasesResponses,
  ListDatabasesAliasData,
  ListDatabasesAliasErrors,
  ListDatabasesAliasResponses,
  ListDatabasesData,
  ListDatabasesErrors,
  ListDatabasesResponses,
  ListDownloadedReposData,
  ListDownloadedReposErrors,
  ListDownloadedReposResponses,
  ListMemosData,
  ListMemosErrors,
  ListMemosResponses,
  ListMissionBranchesData,
  ListMissionBranchesErrors,
  ListMissionBranchesResponses,
  ListMissionCheckpointsData,
  ListMissionCheckpointsErrors,
  ListMissionCheckpointsResponses,
  ListMissionsAliasData,
  ListMissionsAliasErrors,
  ListMissionsAliasResponses,
  ListMissionsData,
  ListMissionsErrors,
  ListMissionsResponses,
  ListProjectsAliasData,
  ListProjectsAliasErrors,
  ListProjectsAliasResponses,
  ListProjectsData,
  ListProjectsErrors,
  ListProjectsResponses,
  ListProposalsData,
  ListProposalsErrors,
  ListProposalsResponses,
  ListPrototypeChatsData,
  ListPrototypeChatsErrors,
  ListPrototypeChatsResponses,
  ListSessionsData,
  ListSessionsErrors,
  ListSessionsResponses,
  ListTablesData,
  ListTablesErrors,
  ListTablesResponses,
  ListTasksData,
  ListTasksErrors,
  ListTasksResponses,
  ListVersionsData,
  ListVersionsErrors,
  ListVersionsResponses,
  ListWorkflowsData,
  ListWorkflowsErrors,
  ListWorkflowsResponses,
  ListWorkspacesData,
  ListWorkspacesErrors,
  ListWorkspacesResponses,
  LockContentData,
  LockContentErrors,
  LockContentResponses,
  LoginData,
  LoginErrors,
  LoginForAccessTokenData,
  LoginForAccessTokenErrors,
  LoginForAccessTokenResponses,
  LoginResponses,
  MoveContentData,
  MoveContentErrors,
  MoveContentResponses,
  PreviewPrototypeChatData,
  PreviewPrototypeChatErrors,
  PreviewPrototypeChatResponses,
  PromoteCheckpointToLongtermData,
  PromoteCheckpointToLongtermErrors,
  PromoteCheckpointToLongtermResponses,
  QueryContentData,
  QueryContentErrors,
  QueryContentResponses,
  QueryKnowledgeBaseData,
  QueryKnowledgeBaseErrors,
  QueryKnowledgeBaseResponses,
  RagKnowledgeBaseData,
  RagKnowledgeBaseErrors,
  RagKnowledgeBaseResponses,
  ReadContentData,
  ReadContentErrors,
  ReadContentResponses,
  RefreshTokensData,
  RefreshTokensErrors,
  RefreshTokensResponses,
  RegenerateMetadataData,
  RegenerateMetadataErrors,
  RegenerateMetadataResponses,
  RegenerateMissionData,
  RegenerateMissionErrors,
  RegenerateMissionResponses,
  RejectProposalData,
  RejectProposalErrors,
  RejectProposalResponses,
  RemoveDatabaseData,
  RemoveDatabaseErrors,
  RemoveDatabaseResponses,
  RemoveLinkedRepoData,
  RemoveLinkedRepoErrors,
  RemoveLinkedRepoResponses,
  RemoveMissionData,
  RemoveMissionErrors,
  RemoveMissionResponses,
  RemoveSessionData,
  RemoveSessionErrors,
  RemoveSessionResponses,
  ResolveMemoData,
  ResolveMemoErrors,
  ResolveMemoResponses,
  ResolveOcxpUriData,
  ResolveOcxpUriErrors,
  ResolveOcxpUriResponses,
  SaveCredentialsData,
  SaveCredentialsErrors,
  SaveCredentialsResponses,
  SearchContentData,
  SearchContentErrors,
  SearchContentResponses,
  SetDefaultDatabaseData,
  SetDefaultDatabaseErrors,
  SetDefaultDatabaseResponses,
  SetDefaultRepoData,
  SetDefaultRepoErrors,
  SetDefaultRepoResponses,
  SetGithubTokenData,
  SetGithubTokenErrors,
  SetGithubTokenResponses,
  StartWorkflowData,
  StartWorkflowErrors,
  StartWorkflowResponses,
  SyncAllReposData,
  SyncAllReposErrors,
  SyncAllReposResponses,
  SyncMissionsData,
  SyncMissionsErrors,
  SyncMissionsResponses,
  SyncPrototypeChatAsyncData,
  SyncPrototypeChatAsyncErrors,
  SyncPrototypeChatAsyncResponses,
  SyncPrototypeChatData,
  SyncPrototypeChatErrors,
  SyncPrototypeChatResponses,
  SyncRepoData,
  SyncRepoErrors,
  SyncRepoResponses,
  SystemInfoData,
  SystemInfoErrors,
  SystemInfoResponses,
  TestCredentialsData,
  TestCredentialsErrors,
  TestCredentialsResponses,
  TestDatabaseConnectionData,
  TestDatabaseConnectionErrors,
  TestDatabaseConnectionResponses,
  ToolCreateMissionData,
  ToolCreateMissionErrors,
  ToolCreateMissionResponses,
  ToolUpdateMissionData,
  ToolUpdateMissionErrors,
  ToolUpdateMissionResponses,
  TriggerRebuildData,
  TriggerRebuildErrors,
  TriggerRebuildResponses,
  UnlockContentData,
  UnlockContentErrors,
  UnlockContentResponses,
  UpdateCredentialsData,
  UpdateCredentialsErrors,
  UpdateCredentialsResponses,
  UpdateDatabaseData,
  UpdateDatabaseErrors,
  UpdateDatabaseResponses,
  UpdateMemoData,
  UpdateMemoErrors,
  UpdateMemoResponses,
  UpdateMissionData,
  UpdateMissionErrors,
  UpdateMissionResponses,
  UpdateProjectData,
  UpdateProjectErrors,
  UpdateProjectResponses,
  UpdateSessionMetadataData,
  UpdateSessionMetadataErrors,
  UpdateSessionMetadataResponses,
  UpdateTaskData,
  UpdateTaskErrors,
  UpdateTaskResponses,
  ValidateOcxpUriData,
  ValidateOcxpUriErrors,
  ValidateOcxpUriResponses,
  ValidateResponseData,
  ValidateResponseErrors,
  ValidateResponseResponses,
  WriteContentData,
  WriteContentErrors,
  WriteContentResponses,
} from './types.gen';

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

/**
 * Resolve Ocxp Uri
 *
 * Resolve OCXP URI to actual file locations.
 *
 * Converts ocxp://workspace/content_type/path to:
 * - S3 URI (s3://bucket/path)
 * - Local filesystem path (/vault/path)
 * - Obsidian URI (obsidian://open?vault=...&file=...)
 *
 * Args:
 * request: Resolution request with URI and mode
 * workspace: Current workspace from auth context
 *
 * Returns:
 * OCXPResolution with resolved paths and existence check
 *
 * Raises:
 * HTTPException: If URI format is invalid or content type is unknown
 */
export const resolveOcxpUri = <ThrowOnError extends boolean = false>(
  options: Options<ResolveOcxpUriData, ThrowOnError>
) =>
  (options.client ?? client).post<ResolveOcxpUriResponses, ResolveOcxpUriErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/resolution/resolve',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Validate Ocxp Uri
 *
 * Validate OCXP URI format and content type.
 *
 * Args:
 * request: Validation request with URI
 *
 * Returns:
 * OCXPValidateResponse with validation result
 */
export const validateOcxpUri = <ThrowOnError extends boolean = false>(
  options: Options<ValidateOcxpUriData, ThrowOnError>
) =>
  (options.client ?? client).post<ValidateOcxpUriResponses, ValidateOcxpUriErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/resolution/validate',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Batch Resolve Ocxp Uris
 *
 * Batch resolve multiple OCXP URIs in a single request.
 *
 * Args:
 * request: Batch resolution request with list of URIs
 * workspace: Current workspace from auth context
 *
 * Returns:
 * OCXPBatchResolveResponse with results and errors
 */
export const batchResolveOcxpUris = <ThrowOnError extends boolean = false>(
  options: Options<BatchResolveOcxpUrisData, ThrowOnError>
) =>
  (options.client ?? client).post<
    BatchResolveOcxpUrisResponses,
    BatchResolveOcxpUrisErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/resolution/batch',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk Read Content
 *
 * Bulk read content.
 */
export const bulkReadContent = <ThrowOnError extends boolean = false>(
  options: Options<BulkReadContentData, ThrowOnError>
) =>
  (options.client ?? client).post<BulkReadContentResponses, BulkReadContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/bulk/read',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk Write Content
 *
 * Bulk write content with metadata sidecar and KB auto-indexing support.
 */
export const bulkWriteContent = <ThrowOnError extends boolean = false>(
  options: Options<BulkWriteContentData, ThrowOnError>
) =>
  (options.client ?? client).post<BulkWriteContentResponses, BulkWriteContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/bulk/write',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk Delete Content
 *
 * Bulk delete content with KB auto-removal support.
 */
export const bulkDeleteContent = <ThrowOnError extends boolean = false>(
  options: Options<BulkDeleteContentData, ThrowOnError>
) =>
  (options.client ?? client).post<
    BulkDeleteContentResponses,
    BulkDeleteContentErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/bulk/delete',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk Move Content
 *
 * Bulk move (copy + delete) content.
 *
 * Performs batch copy followed by batch delete for efficiency.
 * Individual item failures are reported in results.
 */
export const bulkMoveContent = <ThrowOnError extends boolean = false>(
  options: Options<BulkMoveContentData, ThrowOnError>
) =>
  (options.client ?? client).post<BulkMoveContentResponses, BulkMoveContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/bulk/move',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Regenerate metadata for S3 documents
 *
 * Regenerates Bedrock KB metadata sidecars for existing S3 documents.
 *
 * Use cases:
 * - After schema changes (e.g., adding new metadata fields)
 * - Fixing incorrect metadata from previous versions
 * - Bulk metadata updates for a workspace or project
 *
 * Background processing:
 * - If max_files is None or > 1000, job is queued for background processing
 * - Use job_id to check status via /admin/jobs/{job_id} endpoint
 *
 * Dry run mode:
 * - Shows what would change without updating S3
 * - Useful for validating changes before applying
 */
export const regenerateMetadata = <ThrowOnError extends boolean = false>(
  options: Options<RegenerateMetadataData, ThrowOnError>
) =>
  (options.client ?? client).post<
    RegenerateMetadataResponses,
    RegenerateMetadataErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/admin/metadata/regenerate',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Health check
 *
 * Check system health and component status
 */
export const healthCheck = <ThrowOnError extends boolean = false>(
  options?: Options<HealthCheckData, ThrowOnError>
) =>
  (options?.client ?? client).get<HealthCheckResponses, HealthCheckErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/admin/health',
    ...options,
  });

/**
 * System information
 *
 * Get system configuration and runtime information
 */
export const systemInfo = <ThrowOnError extends boolean = false>(
  options?: Options<SystemInfoData, ThrowOnError>
) =>
  (options?.client ?? client).get<SystemInfoResponses, SystemInfoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/admin/info',
    ...options,
  });

/**
 * Discover Context
 *
 * Discover relevant context using smart strategy selection.
 *
 * OCXP automatically selects the best retrieval strategy:
 * - **Semantic search** (default): Fast vector similarity search
 * - **RAG with LLM answer**: When `include_answer=True`
 * - **Hybrid search**: When `search_type=HYBRID`
 *
 * The response includes:
 * - **results**: Ranked context snippets with scores
 * - **answer**: LLM-generated answer (only if include_answer=True)
 * - **strategy_used**: Which strategy was applied
 * - **reranked**: Whether results were quality-reranked
 *
 * **Replaces:**
 * - `POST /ocxp/kb/query` - Use this with default options
 * - `POST /ocxp/kb/rag` - Use this with `include_answer=True`
 *
 * **Example Request:**
 * ```json
 * {
 * "query": "How does authentication work?",
 * "options": {
 * "content_type": "code",
 * "project": "brain",
 * "include_answer": true,
 * "max_results": 5
 * }
 * }
 * ```
 */
export const discoverContext = <ThrowOnError extends boolean = false>(
  options: Options<DiscoverContextData, ThrowOnError>
) =>
  (options.client ?? client).post<DiscoverContextResponses, DiscoverContextErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/discover',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Validate Response
 *
 * Validate AI response against context.
 *
 * Checks for:
 * - **Hallucination**: Claims not supported by context
 * - **Outdated**: References to stale information
 * - **Incomplete**: Missing key context
 * - **Contradiction**: Conflicts with source context
 *
 * The response includes:
 * - **valid**: True if no high-severity issues found
 * - **confidence**: Confidence in validation (0.0 - 1.0)
 * - **quality_score**: Overall quality score (0.0 - 1.0)
 * - **issues**: List of specific issues found
 * - **verified_claims**: Number of claims verified against context
 * - **unverified_claims**: Number of claims that couldn't be verified
 *
 * **Example Request:**
 * ```json
 * {
 * "response": "The authentication uses JWT tokens with a 1-hour expiry.",
 * "context_ids": ["kb-0", "kb-1", "kb-2"],
 * "query": "How does authentication work?",
 * "strict_mode": false
 * }
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "valid": true,
 * "confidence": 0.85,
 * "quality_score": 0.9,
 * "issues": [],
 * "verified_claims": 5,
 * "unverified_claims": 1
 * }
 * ```
 */
export const validateResponse = <ThrowOnError extends boolean = false>(
  options: Options<ValidateResponseData, ThrowOnError>
) =>
  (options.client ?? client).post<ValidateResponseResponses, ValidateResponseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/validate',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Ingest Documents
 *
 * Ingest documents directly into Bedrock KB.
 *
 * Triggers immediate indexing of specific documents that already exist in S3.
 * Documents are batched (max 25 per API call) for efficiency.
 *
 * **Prerequisites:**
 * - Documents must already be written to S3 via OCXP content API
 * - Each document should have a `.metadata.json` sidecar for filtering
 *
 * **Use Case:**
 * Called from Obsidian plugin when user clicks "Index Now" button
 * to immediately index pending files instead of waiting for 5-min sync.
 *
 * **Example Request:**
 * ```json
 * {
 * "documents": [
 * {"path": "project/uuid/auth.md"},
 * {"path": "project/uuid/flows/login.md"}
 * ]
 * }
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "indexed": 2,
 * "failed": 0,
 * "skipped": 0,
 * "results": [
 * {"path": "project/uuid/auth.md", "status": "indexed"},
 * {"path": "project/uuid/flows/login.md", "status": "indexed"}
 * ]
 * }
 * ```
 */
export const ingestDocuments = <ThrowOnError extends boolean = false>(
  options: Options<IngestDocumentsData, ThrowOnError>
) =>
  (options.client ?? client).post<IngestDocumentsResponses, IngestDocumentsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/ingest',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Analyse Visual Content
 *
 * Analyze visual content using direct vision model (Claude 3 Sonnet).
 *
 * Two modes:
 * 1. **Direct paths**: Provide `image_paths` to analyze specific images
 * 2. **Search + analyze**: Provide `search_query` to find relevant images first
 *
 * The endpoint:
 * - Loads images from S3 (contexthub-visual bucket)
 * - Sends them to Claude 3 Sonnet vision model
 * - Returns AI analysis based on actual image content
 *
 * **Why Two Stages?**
 *
 * The Visual KB uses text embeddings (Titan Text V2), NOT image embeddings.
 * This means KB search can only find images by metadata (descriptions, tags, filenames),
 * not by visual similarity or content. This endpoint provides the second stage:
 * once you have image paths (from discover_visual or directly), analyze the actual pixels.
 *
 * **Example Request (direct paths):**
 * ```json
 * {
 * "question": "What UI patterns are shown in these screenshots?",
 * "image_paths": [
 * "screenshots/mission-123/login.png",
 * "screenshots/mission-123/dashboard.png"
 * ],
 * "max_images": 5
 * }
 * ```
 *
 * **Example Request (search + analyze):**
 * ```json
 * {
 * "question": "What authentication methods are visible?",
 * "search_query": "login authentication forms",
 * "max_images": 5,
 * "mission_id": "abc-123"
 * }
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "answer": "The screenshots show a login page with email/password fields and a 'Remember me' checkbox. The dashboard includes a navigation sidebar with user profile section...",
 * "images_analyzed": [
 * {
 * "s3_path": "workspaces/prod/visual/screenshots/mission-123/login.png",
 * "ocxp_link": "ocxp://prod/visual/screenshots/mission-123/login.png",
 * "analyzed": true
 * },
 * {
 * "s3_path": "workspaces/prod/visual/screenshots/mission-123/dashboard.png",
 * "ocxp_link": "ocxp://prod/visual/screenshots/mission-123/dashboard.png",
 * "analyzed": true
 * }
 * ],
 * "total_images": 2,
 * "model_used": "anthropic.claude-3-sonnet-20240229-v1:0",
 * "mission_id": "abc-123"
 * }
 * ```
 *
 * **Image Path Formats:**
 * - Relative: `screenshots/mission-123/login.png` -> auto-prefixed with workspace
 * - Visual prefix: `visual/screenshots/...` -> auto-prefixed with workspace
 * - Full S3 key: `workspaces/prod/visual/screenshots/...` -> used as-is
 *
 * **Supported Image Formats:**
 * - PNG, JPEG, GIF, WebP
 * - Auto-detected from file extension or magic bytes
 */
export const analyseVisualContent = <ThrowOnError extends boolean = false>(
  options: Options<AnalyseVisualContentData, ThrowOnError>
) =>
  (options.client ?? client).post<
    AnalyseVisualContentResponses,
    AnalyseVisualContentErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/visual/analyse',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Capture Screenshot
 *
 * Capture a screenshot of a webpage.
 *
 * Uses browser automation to navigate to URL and capture screenshot.
 * Screenshot is stored in OCXP visual storage.
 *
 * In mock mode (BROWSER_MOCK_MODE=true), returns a placeholder screenshot
 * for stress testing without requiring Lambda/AgentCore.
 */
export const captureScreenshot = <ThrowOnError extends boolean = false>(
  options: Options<CaptureScreenshotData, ThrowOnError>
) =>
  (options.client ?? client).post<
    CaptureScreenshotResponses,
    CaptureScreenshotErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/visual/screenshot',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Browse Page
 *
 * Browse a webpage with optional interactions.
 *
 * Navigates to URL, performs actions (fill forms, click buttons),
 * and optionally extracts content and captures screenshot.
 *
 * In mock mode (BROWSER_MOCK_MODE=true), returns placeholder responses
 * for stress testing without requiring Lambda/AgentCore.
 */
export const browsePage = <ThrowOnError extends boolean = false>(
  options: Options<BrowsePageData, ThrowOnError>
) =>
  (options.client ?? client).post<BrowsePageResponses, BrowsePageErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/visual/browse',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Extract Elements
 *
 * Extract elements from a webpage.
 *
 * Navigates to URL and extracts specified element types
 * (links, forms, buttons, images, headings, or all).
 *
 * In mock mode (BROWSER_MOCK_MODE=true), returns placeholder elements
 * for stress testing without requiring Lambda/AgentCore.
 */
export const extractElements = <ThrowOnError extends boolean = false>(
  options: Options<ExtractElementsData, ThrowOnError>
) =>
  (options.client ?? client).post<ExtractElementsResponses, ExtractElementsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/visual/extract',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Compare Pages
 *
 * Compare two webpages.
 *
 * Captures both pages and compares them based on compare_type:
 * - visual: Screenshot similarity
 * - structure: DOM structure comparison
 * - content: Text content comparison
 *
 * In mock mode (BROWSER_MOCK_MODE=true), returns placeholder comparison
 * for stress testing without requiring Lambda/AgentCore.
 */
export const comparePages = <ThrowOnError extends boolean = false>(
  options: Options<ComparePagesData, ThrowOnError>
) =>
  (options.client ?? client).post<ComparePagesResponses, ComparePagesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/visual/compare',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List Prototype Chats
 *
 * List all accessible prototype chats.
 *
 * Returns a list of chats that are accessible with the configured API key.
 * Use this to discover which chats can be linked to missions.
 *
 * **Query Parameters:**
 * - `provider`: Provider name (v0, lovable, bolt) - default: v0
 *
 * **Example Response:**
 * ```json
 * {
 * "provider": "v0",
 * "chats": [
 * {
 * "id": "qFPCm5zzimu",
 * "name": "Mission Dashboard",
 * "web_url": "https://v0.app/chat/qFPCm5zzimu",
 * "privacy": "team",
 * "latest_preview_url": "https://demo-xxx.vusercontent.net"
 * }
 * ],
 * "total": 5
 * }
 * ```
 */
export const listPrototypeChats = <ThrowOnError extends boolean = false>(
  options?: Options<ListPrototypeChatsData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListPrototypeChatsResponses,
    ListPrototypeChatsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/list',
    ...options,
  });

/**
 * Preview Prototype Chat
 *
 * Preview a prototype chat before linking.
 *
 * Fetches chat metadata and version list without storing anything.
 * Use this to show available versions in Obsidian UI before the user
 * selects which version to link to a mission.
 *
 * **Example Request:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_url": "https://v0.dev/chat/abc123"
 * }
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "abc123",
 * "web_url": "https://v0.dev/chat/abc123",
 * "messages_count": 15,
 * "versions": [
 * {"id": "v1", "preview_url": "https://abc123.vercel.app", "files": ["page.tsx", "layout.tsx"]},
 * {"id": "v2", "preview_url": "https://abc123-v2.vercel.app", "files": ["page.tsx", "layout.tsx", "sidebar.tsx"]}
 * ],
 * "latest_preview_url": "https://abc123-v2.vercel.app",
 * "can_download_files": true
 * }
 * ```
 */
export const previewPrototypeChat = <ThrowOnError extends boolean = false>(
  options: Options<PreviewPrototypeChatData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PreviewPrototypeChatResponses,
    PreviewPrototypeChatErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/preview',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Link Prototype Chat
 *
 * Link a prototype chat to a mission.
 *
 * Fetches the full conversation history and optionally downloads version files
 * from the prototype provider (v0, Lovable, Bolt). Stores everything in OCXP
 * and optionally screenshots the preview.
 *
 * **Workflow for Obsidian:**
 * 1. User enters chat URL in mission creation form
 * 2. Obsidian calls `/preview` to get available versions
 * 3. User selects a version
 * 4. Obsidian calls `/link` with version_id to download files
 *
 * **What gets stored:**
 * - `conversation.md` - Full chat history as searchable markdown (KB indexed)
 * - `metadata.json` - Structured metadata for programmatic access
 * - `versions/{version_id}*.tsx` - Actual code files from selected version
 * - `screenshots/preview.png` - Screenshot of the preview URL
 *
 * **Example Request:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_url": "https://v0.dev/chat/abc123",
 * "version_id": "v2",
 * "mission_id": "mission-xyz",
 * "download_files": true,
 * "screenshot_preview": true
 * }
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "abc123",
 * "web_url": "https://v0.dev/chat/abc123",
 * "mission_id": "mission-xyz",
 * "messages_count": 15,
 * "versions_count": 2,
 * "latest_preview_url": "https://abc123-v2.vercel.app",
 * "screenshot_link": "ocxp://prod/visual/prototype-chats/mission-xyz/v0/abc123/screenshots/preview.png",
 * "content_links": [
 * "ocxp://prod/visual/prototype-chats/mission-xyz/v0/abc123/conversation.md",
 * "ocxp://prod/visual/prototype-chats/mission-xyz/v0/abc123/versions/v2/page.tsx"
 * ],
 * "indexed": true
 * }
 * ```
 */
export const linkPrototypeChat = <ThrowOnError extends boolean = false>(
  options: Options<LinkPrototypeChatData, ThrowOnError>
) =>
  (options.client ?? client).post<
    LinkPrototypeChatResponses,
    LinkPrototypeChatErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/link',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Sync Prototype Chat
 *
 * Sync/refresh a linked prototype chat with latest changes.
 *
 * Re-fetches the conversation and version data from the provider
 * and updates the stored content in OCXP.
 *
 * **Example Request:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "abc123",
 * "mission_id": "mission-xyz"
 * }
 * ```
 */
export const syncPrototypeChat = <ThrowOnError extends boolean = false>(
  options: Options<SyncPrototypeChatData, ThrowOnError>
) =>
  (options.client ?? client).post<
    SyncPrototypeChatResponses,
    SyncPrototypeChatErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/sync',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get Stored Versions
 *
 * Get stored version IDs from DynamoDB (fast, no S3/API calls).
 *
 * This is a lightweight endpoint optimized for sub-100ms response times.
 * Use this to quickly check which versions are already downloaded without
 * triggering a full sync operation.
 *
 * **Path Parameters:**
 * - `provider`: Provider name (v0, lovable, bolt)
 * - `chat_id`: Chat ID
 *
 * **Query Parameters:**
 * - `include_details`: If true, returns full version metadata (files, pages, screenshots)
 *
 * **Use Cases:**
 * - Determine "Download" vs "Reload" button state for each version
 * - Check if "Sync Latest" button should be disabled (latest already stored)
 * - Get full version details for Files/Pages tabs (when include_details=true)
 *
 * **Example Response (include_details=false):**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "YivecgytPyg",
 * "stored_versions": ["aVVgJPrZiiE", "8xP0kUQqTxe", "cTeBCcjCGbM"],
 * "latest_version_id": "cTeBCcjCGbM",
 * "version_details": []
 * }
 * ```
 *
 * **Example Response (include_details=true):**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "YivecgytPyg",
 * "stored_versions": ["aVVgJPrZiiE"],
 * "latest_version_id": "cTeBCcjCGbM",
 * "version_details": [
 * {
 * "id": "aVVgJPrZiiE",
 * "preview_url": "https://demo.vusercontent.net/...",
 * "screenshot_link": "ocxp://...",
 * "files": ["app/page.tsx", "app/layout.tsx"],
 * "pages": [{"route": "/", "file": "app/page.tsx", "screenshot_link": "ocxp://..."}],
 * "created_at": "2024-01-15T10:30:00Z",
 * "synced_at": "2024-01-15T10:35:00Z"
 * }
 * ]
 * }
 * ```
 */
export const getStoredVersions = <ThrowOnError extends boolean = false>(
  options: Options<GetStoredVersionsData, ThrowOnError>
) =>
  (options.client ?? client).get<GetStoredVersionsResponses, GetStoredVersionsErrors, ThrowOnError>(
    {
      security: [{ scheme: 'bearer', type: 'http' }],
      url: '/ocxp/prototype/chat/{provider}/{chat_id}/stored-versions',
      ...options,
    }
  );

/**
 * Capture Page Screenshots
 *
 * Capture screenshots for specific pages of a prototype version.
 *
 * Use this endpoint to capture screenshots for auto-discovered pages without
 * triggering a full sync. This is useful when pages are detected from file
 * structure but screenshots haven't been captured yet.
 *
 * **Path Parameters:**
 * - `provider`: Provider name (v0, lovable, bolt)
 * - `chat_id`: Chat ID
 *
 * **Request Body:**
 * - `version_id`: Version ID to capture screenshots for
 * - `routes`: List of routes to screenshot (e.g., ['/', '/dashboard', '/settings'])
 *
 * **Use Cases:**
 * - Capture screenshots for newly discovered pages after file sync
 * - Re-capture screenshots after preview URL changes
 * - Capture screenshots for specific routes without full resync
 *
 * **Example Request:**
 * ```json
 * {
 * "version_id": "aVVgJPrZiiE",
 * "routes": ["/", "/dashboard", "/settings"]
 * }
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "YivecgytPyg",
 * "version_id": "aVVgJPrZiiE",
 * "screenshots": {
 * "/": "ocxp://prod/prototype/FQV1NSmpVqk/YivecgytPyg/aVVgJPrZiiE/visual/screenshots/root.png",
 * "/dashboard": "ocxp://prod/prototype/FQV1NSmpVqk/YivecgytPyg/aVVgJPrZiiE/visual/screenshots/dashboard.png",
 * "/settings": "ocxp://prod/prototype/FQV1NSmpVqk/YivecgytPyg/aVVgJPrZiiE/visual/screenshots/settings.png"
 * },
 * "captured_count": 3,
 * "failed_routes": []
 * }
 * ```
 */
export const capturePageScreenshots = <ThrowOnError extends boolean = false>(
  options: Options<CapturePageScreenshotsData, ThrowOnError>
) =>
  (options.client ?? client).post<
    CapturePageScreenshotsResponses,
    CapturePageScreenshotsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/{provider}/{chat_id}/screenshots',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get Prototype Chat
 *
 * Get stored prototype chat data from OCXP.
 *
 * Returns the stored conversation, versions, and file links for a
 * previously linked prototype chat.
 *
 * **Path Parameters:**
 * - `provider`: Provider name (v0, lovable, bolt)
 * - `chat_id`: Chat ID
 *
 * **Query Parameters:**
 * - `project_id`: Project ID (use "no-project" if chat has no project)
 * - `version_id`: Version ID to retrieve
 *
 * **Example Response:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "abc123",
 * "web_url": "https://v0.dev/chat/abc123",
 * "mission_id": "mission-xyz",
 * "messages": [...],
 * "versions": [...],
 * "conversation_link": "ocxp://prod/prototype/FQV1NSmpVqk/abc123/aVVgJPrZiiE/docs/conversation.md",
 * "file_links": [
 * "ocxp://prod/prototype/FQV1NSmpVqk/abc123/aVVgJPrZiiE/code/page.tsx"
 * ]
 * }
 * ```
 */
export const getPrototypeChat = <ThrowOnError extends boolean = false>(
  options: Options<GetPrototypeChatData, ThrowOnError>
) =>
  (options.client ?? client).get<GetPrototypeChatResponses, GetPrototypeChatErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/{provider}/{chat_id}',
    ...options,
  });

/**
 * Sync Prototype Chat Async
 *
 * Start an async prototype chat sync job (202 Accepted).
 *
 * Creates a job and queues it for background processing. Returns immediately
 * with a job_id that can be used to poll for status or receive WebSocket updates.
 *
 * **Benefits:**
 * - Immediate response (no timeout on long syncs)
 * - Real-time progress updates via WebSocket
 * - Resumable on failure (job tracked in DynamoDB)
 * - Better suited for large chats with many files/screenshots
 *
 * **Frontend Integration:**
 *
 * Option 1: Polling
 * ```javascript
 * const { job_id } = await fetch('/ocxp/prototype/chat/sync-async', {
 * method: 'POST',
 * body: JSON.stringify({ chat_id: 'xxx', mission_id: 'yyy' })
 * }).then(r => r.json());
 *
 * // Poll every second
 * while (status !== 'complete' && status !== 'failed') {
 * await sleep(1000);
 * const job = await fetch(`/ocxp/prototype/chat/sync-status/${job_id}`).then(r => r.json());
 * updateProgressBar(job.progress);
 * }
 * ```
 *
 * Option 2: WebSocket
 * ```javascript
 * ws.onmessage = (msg) => {
 * if (msg.type === 'prototype_sync_progress') {
 * updateProgressBar(msg.progress, msg.current_step);
 * }
 * if (msg.type === 'prototype_sync_complete') {
 * handleComplete(msg.content_links);
 * }
 * };
 * ```
 *
 * **Example Request:**
 * ```json
 * {
 * "provider": "v0",
 * "chat_id": "YivecgytPyg",
 * "mission_id": "mission-xyz",
 * "download_files": true,
 * "download_screenshots": true
 * }
 * ```
 *
 * **Example Response (202 Accepted):**
 * ```json
 * {
 * "job_id": "job-a1b2c3d4e5f6",
 * "status": "queued",
 * "message": "Job queued for processing"
 * }
 * ```
 */
export const syncPrototypeChatAsync = <ThrowOnError extends boolean = false>(
  options: Options<SyncPrototypeChatAsyncData, ThrowOnError>
) =>
  (options.client ?? client).post<
    SyncPrototypeChatAsyncResponses,
    SyncPrototypeChatAsyncErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/sync-async',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get Sync Status
 *
 * Get the current status of an async sync job.
 *
 * Use this endpoint to poll for progress updates on a sync job.
 * For real-time updates, prefer WebSocket subscription instead.
 *
 * **Path Parameters:**
 * - `job_id`: Job identifier from sync-async response
 *
 * **Example Response (in progress):**
 * ```json
 * {
 * "job_id": "job-a1b2c3d4e5f6",
 * "status": "downloading",
 * "progress": 35,
 * "current_step": "Downloading files for version 2/5...",
 * "files_processed": 12,
 * "files_total": 34,
 * "screenshots_processed": 1,
 * "screenshots_total": 5,
 * "content_links": [],
 * "error": null,
 * "created_at": "2024-01-15T10:30:00Z",
 * "updated_at": "2024-01-15T10:30:15Z"
 * }
 * ```
 *
 * **Example Response (complete):**
 * ```json
 * {
 * "job_id": "job-a1b2c3d4e5f6",
 * "status": "complete",
 * "progress": 100,
 * "current_step": "Complete",
 * "files_processed": 34,
 * "files_total": 34,
 * "screenshots_processed": 5,
 * "screenshots_total": 5,
 * "content_links": [
 * "ocxp://prod/prototype/FQV1NSmpVqk/chat123/v1/docs/conversation.md",
 * "ocxp://prod/prototype/FQV1NSmpVqk/chat123/v1/code/page.tsx"
 * ],
 * "error": null,
 * "created_at": "2024-01-15T10:30:00Z",
 * "updated_at": "2024-01-15T10:31:00Z"
 * }
 * ```
 */
export const getSyncStatus = <ThrowOnError extends boolean = false>(
  options: Options<GetSyncStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<GetSyncStatusResponses, GetSyncStatusErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/prototype/chat/sync-status/{job_id}',
    ...options,
  });

/**
 * List all sessions
 *
 * Returns sessions for the workspace filtered by status. Uses AgentCore Memory when available for fast retrieval. Ordered by most recently updated.
 */
export const listSessions = <ThrowOnError extends boolean = false>(
  options?: Options<ListSessionsData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListSessionsResponses, ListSessionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/session',
    ...options,
  });

/**
 * Create session
 *
 * Creates a new session linked to a mission in DynamoDB. Used by Brain to establish session-mission relationship.
 */
export const createSession = <ThrowOnError extends boolean = false>(
  options: Options<CreateSessionData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateSessionResponses, CreateSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/session',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get session messages
 *
 * Loads message history for a session from S3 storage.
 */
export const getSessionMessages = <ThrowOnError extends boolean = false>(
  options: Options<GetSessionMessagesData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetSessionMessagesResponses,
    GetSessionMessagesErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/session/{session_id}/messages',
    ...options,
  });

/**
 * Update session metadata
 *
 * Updates session title and message count. Creates session if it does not exist.
 */
export const updateSessionMetadata = <ThrowOnError extends boolean = false>(
  options: Options<UpdateSessionMetadataData, ThrowOnError>
) =>
  (options.client ?? client).post<
    UpdateSessionMetadataResponses,
    UpdateSessionMetadataErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/session/{session_id}/metadata',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Fork session
 *
 * Creates a new session branched from an existing one at a specified message point.
 */
export const forkSession = <ThrowOnError extends boolean = false>(
  options: Options<ForkSessionData, ThrowOnError>
) =>
  (options.client ?? client).post<ForkSessionResponses, ForkSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/session/{session_id}/fork',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Archive session
 *
 * Soft deletes a session by changing its status to archived.
 */
export const archiveSession = <ThrowOnError extends boolean = false>(
  options: Options<ArchiveSessionData, ThrowOnError>
) =>
  (options.client ?? client).post<ArchiveSessionResponses, ArchiveSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/session/{session_id}/archive',
    ...options,
  });

/**
 * List mission checkpoints
 *
 * Returns all checkpoints for a mission from AgentCore Memory, optionally filtered by branch
 */
export const listMissionCheckpoints = <ThrowOnError extends boolean = false>(
  options: Options<ListMissionCheckpointsData, ThrowOnError>
) =>
  (options.client ?? client).get<
    ListMissionCheckpointsResponses,
    ListMissionCheckpointsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/missions/{mission_id}/checkpoints',
    ...options,
  });

/**
 * Get checkpoint details
 *
 * Returns detailed checkpoint information including metadata
 */
export const getCheckpoint = <ThrowOnError extends boolean = false>(
  options: Options<GetCheckpointData, ThrowOnError>
) =>
  (options.client ?? client).get<GetCheckpointResponses, GetCheckpointErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/checkpoints/{checkpoint_id}',
    ...options,
  });

/**
 * List checkpoint branches
 *
 * Returns all branches for a mission
 */
export const listMissionBranches = <ThrowOnError extends boolean = false>(
  options: Options<ListMissionBranchesData, ThrowOnError>
) =>
  (options.client ?? client).get<
    ListMissionBranchesResponses,
    ListMissionBranchesErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/missions/{mission_id}/checkpoints/branches',
    ...options,
  });

/**
 * Export checkpoint as SOP markdown
 *
 * Export checkpoint data as a Standard Operating Procedure .md file
 */
export const exportCheckpointAsSop = <ThrowOnError extends boolean = false>(
  options: Options<ExportCheckpointAsSopData, ThrowOnError>
) =>
  (options.client ?? client).post<
    ExportCheckpointAsSopResponses,
    ExportCheckpointAsSopErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/checkpoints/{checkpoint_id}/export',
    ...options,
  });

/**
 * Promote checkpoint to long-term memory
 *
 * Convert checkpoint event to long-term memory record for permanent storage
 */
export const promoteCheckpointToLongterm = <ThrowOnError extends boolean = false>(
  options: Options<PromoteCheckpointToLongtermData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PromoteCheckpointToLongtermResponses,
    PromoteCheckpointToLongtermErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/checkpoints/{checkpoint_id}/promote',
    ...options,
  });

/**
 * List all projects
 *
 * Returns all projects in the workspace with their linked repos and missions.
 */
export const listProjects = <ThrowOnError extends boolean = false>(
  options?: Options<ListProjectsData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListProjectsResponses, ListProjectsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project',
    ...options,
  });

/**
 * Create a new project
 *
 * Creates a project with auto-generated UUID. Projects link repos, missions, and sessions for context scoping.
 */
export const createProject = <ThrowOnError extends boolean = false>(
  options: Options<CreateProjectData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateProjectResponses, CreateProjectErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List all projects (alias)
 *
 * Alias for GET /ocxp/project. Returns all projects in the workspace.
 */
export const listProjectsAlias = <ThrowOnError extends boolean = false>(
  options?: Options<ListProjectsAliasData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListProjectsAliasResponses,
    ListProjectsAliasErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/list',
    ...options,
  });

/**
 * Delete project
 *
 * Permanently deletes a project and its metadata. Linked repos are not deleted.
 */
export const deleteProject = <ThrowOnError extends boolean = false>(
  options: Options<DeleteProjectData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteProjectResponses, DeleteProjectErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}',
    ...options,
  });

/**
 * Get project details
 *
 * Returns full project details including linked repos, missions, and metadata.
 */
export const getProject = <ThrowOnError extends boolean = false>(
  options: Options<GetProjectData, ThrowOnError>
) =>
  (options.client ?? client).get<GetProjectResponses, GetProjectErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}',
    ...options,
  });

/**
 * Update project
 *
 * Updates project name and/or description. Only provided fields are updated.
 */
export const updateProject = <ThrowOnError extends boolean = false>(
  options: Options<UpdateProjectData, ThrowOnError>
) =>
  (options.client ?? client).put<UpdateProjectResponses, UpdateProjectErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Link repository to project
 *
 * Links a repository to the project with category, priority, and auto-include settings for KB queries.
 */
export const addLinkedRepo = <ThrowOnError extends boolean = false>(
  options: Options<AddLinkedRepoData, ThrowOnError>
) =>
  (options.client ?? client).post<AddLinkedRepoResponses, AddLinkedRepoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/repos',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Unlink repository from project
 *
 * Removes a repository link from the project. The repository itself is not deleted.
 */
export const removeLinkedRepo = <ThrowOnError extends boolean = false>(
  options: Options<RemoveLinkedRepoData, ThrowOnError>
) =>
  (options.client ?? client).delete<
    RemoveLinkedRepoResponses,
    RemoveLinkedRepoErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/repos/{repo_id}',
    ...options,
  });

/**
 * Set default repository
 *
 * Sets the default repository for the project. Used for integration and primary context.
 */
export const setDefaultRepo = <ThrowOnError extends boolean = false>(
  options: Options<SetDefaultRepoData, ThrowOnError>
) =>
  (options.client ?? client).put<SetDefaultRepoResponses, SetDefaultRepoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/default-repo',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get context repositories
 *
 * Returns all repositories marked for auto-include in KB queries.
 */
export const getContextRepos = <ThrowOnError extends boolean = false>(
  options: Options<GetContextReposData, ThrowOnError>
) =>
  (options.client ?? client).get<GetContextReposResponses, GetContextReposErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/context-repos',
    ...options,
  });

/**
 * Add mission to project
 *
 * Associates a mission with the project for context grouping.
 */
export const addMission = <ThrowOnError extends boolean = false>(
  options: Options<AddMissionData, ThrowOnError>
) =>
  (options.client ?? client).post<AddMissionResponses, AddMissionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/missions',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Remove mission from project
 *
 * Removes the mission association from the project. The mission itself is not deleted.
 */
export const removeMission = <ThrowOnError extends boolean = false>(
  options: Options<RemoveMissionData, ThrowOnError>
) =>
  (options.client ?? client).delete<RemoveMissionResponses, RemoveMissionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/missions/{mission_id}',
    ...options,
  });

/**
 * Sync project missions
 *
 * Validates active_mission_ids against mission metadata table and removes orphaned IDs.
 */
export const syncMissions = <ThrowOnError extends boolean = false>(
  options: Options<SyncMissionsData, ThrowOnError>
) =>
  (options.client ?? client).post<SyncMissionsResponses, SyncMissionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/missions/sync',
    ...options,
  });

/**
 * Get project databases
 *
 * Returns all databases linked to the project.
 */
export const getProjectDatabases = <ThrowOnError extends boolean = false>(
  options: Options<GetProjectDatabasesData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetProjectDatabasesResponses,
    GetProjectDatabasesErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/databases',
    ...options,
  });

/**
 * Link database to project
 *
 * Links a database configuration to the project for agent context.
 */
export const addDatabase = <ThrowOnError extends boolean = false>(
  options: Options<AddDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).post<AddDatabaseResponses, AddDatabaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/databases',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Unlink database from project
 *
 * Removes a database link from the project. The database config is not deleted.
 */
export const removeDatabase = <ThrowOnError extends boolean = false>(
  options: Options<RemoveDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).delete<RemoveDatabaseResponses, RemoveDatabaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/databases/{database_id}',
    ...options,
  });

/**
 * Set default database
 *
 * Sets the default database for the project. Used when no specific database_id is provided.
 */
export const setDefaultDatabase = <ThrowOnError extends boolean = false>(
  options: Options<SetDefaultDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).put<
    SetDefaultDatabaseResponses,
    SetDefaultDatabaseErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/default-database',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Download project pack as ZIP
 *
 * Download complete project as ZIP file.
 *
 * Includes:
 * - All project files (docs, configs, etc.)
 * - Preserves folder structure
 * - Excludes archive/ folders and .metadata.json files
 */
export const downloadProjectPack = <ThrowOnError extends boolean = false>(
  options: Options<DownloadProjectPackData, ThrowOnError>
) =>
  (options.client ?? client).get<
    DownloadProjectPackResponses,
    DownloadProjectPackErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/download',
    ...options,
  });

/**
 * Delete project credentials
 *
 * Delete credentials for a project.
 */
export const deleteCredentials = <ThrowOnError extends boolean = false>(
  options: Options<DeleteCredentialsData, ThrowOnError>
) =>
  (options.client ?? client).delete<
    DeleteCredentialsResponses,
    DeleteCredentialsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/credentials',
    ...options,
  });

/**
 * Get project credentials
 *
 * Retrieve credentials for a project with decrypted password.
 */
export const getCredentials = <ThrowOnError extends boolean = false>(
  options: Options<GetCredentialsData, ThrowOnError>
) =>
  (options.client ?? client).get<GetCredentialsResponses, GetCredentialsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/credentials',
    ...options,
  });

/**
 * Update project credentials
 *
 * Update specific fields of project credentials.
 */
export const updateCredentials = <ThrowOnError extends boolean = false>(
  options: Options<UpdateCredentialsData, ThrowOnError>
) =>
  (options.client ?? client).patch<
    UpdateCredentialsResponses,
    UpdateCredentialsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/credentials',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Save project credentials
 *
 * Save or update credentials for a project with encrypted password.
 */
export const saveCredentials = <ThrowOnError extends boolean = false>(
  options: Options<SaveCredentialsData, ThrowOnError>
) =>
  (options.client ?? client).post<SaveCredentialsResponses, SaveCredentialsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/credentials',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Test project credentials
 *
 * Test credentials with actual browser-based login attempt. Returns detailed results including screenshot.
 */
export const testCredentials = <ThrowOnError extends boolean = false>(
  options: Options<TestCredentialsData, ThrowOnError>
) =>
  (options.client ?? client).post<TestCredentialsResponses, TestCredentialsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/project/{project_id}/credentials/test',
    ...options,
  });

/**
 * List all missions
 *
 * Returns all missions in the workspace, optionally filtered by project or mission IDs.
 */
export const listMissions = <ThrowOnError extends boolean = false>(
  options?: Options<ListMissionsData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListMissionsResponses, ListMissionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission',
    ...options,
  });

/**
 * Create a new mission
 *
 * Creates a mission with auto-generated UUID and context folder.
 */
export const createMission = <ThrowOnError extends boolean = false>(
  options: Options<CreateMissionData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateMissionResponses, CreateMissionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List all missions (alias)
 *
 * Alias for GET /ocxp/mission. Returns all missions in the workspace.
 */
export const listMissionsAlias = <ThrowOnError extends boolean = false>(
  options?: Options<ListMissionsAliasData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListMissionsAliasResponses,
    ListMissionsAliasErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/list',
    ...options,
  });

/**
 * Delete mission
 *
 * Permanently deletes a mission and its metadata.
 */
export const deleteMission = <ThrowOnError extends boolean = false>(
  options: Options<DeleteMissionData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteMissionResponses, DeleteMissionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}',
    ...options,
  });

/**
 * Get mission details
 *
 * Returns full mission details including status, progress, and linked sessions.
 */
export const getMission = <ThrowOnError extends boolean = false>(
  options: Options<GetMissionData, ThrowOnError>
) =>
  (options.client ?? client).get<GetMissionResponses, GetMissionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}',
    ...options,
  });

/**
 * Update mission
 *
 * Updates mission metadata. Only provided fields are updated.
 */
export const updateMission = <ThrowOnError extends boolean = false>(
  options: Options<UpdateMissionData, ThrowOnError>
) =>
  (options.client ?? client).put<UpdateMissionResponses, UpdateMissionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Add session to mission
 *
 * Associates a session with the mission.
 */
export const addSession = <ThrowOnError extends boolean = false>(
  options: Options<AddSessionData, ThrowOnError>
) =>
  (options.client ?? client).post<AddSessionResponses, AddSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/sessions',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Remove session from mission
 *
 * Removes the session association from the mission. The session itself is not deleted.
 */
export const removeSession = <ThrowOnError extends boolean = false>(
  options: Options<RemoveSessionData, ThrowOnError>
) =>
  (options.client ?? client).delete<RemoveSessionResponses, RemoveSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/sessions/{session_id}',
    ...options,
  });

/**
 * Regenerate mission
 *
 * Archives old generated docs and triggers AgentCore regeneration with updated ticket info.
 */
export const regenerateMission = <ThrowOnError extends boolean = false>(
  options: Options<RegenerateMissionData, ThrowOnError>
) =>
  (options.client ?? client).post<
    RegenerateMissionResponses,
    RegenerateMissionErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/regenerate',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Download mission pack as ZIP
 *
 * Download complete mission as ZIP file.
 *
 * Includes:
 * - All mission files (PHASES.md, TASKS.md, README.md, documents/)
 * - Mission metadata JSON
 * - Preserves folder structure
 * - Excludes archive/ folders
 */
export const downloadMissionPack = <ThrowOnError extends boolean = false>(
  options: Options<DownloadMissionPackData, ThrowOnError>
) =>
  (options.client ?? client).get<
    DownloadMissionPackResponses,
    DownloadMissionPackErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/download',
    ...options,
  });

/**
 * Trigger smart re-execution from feedback
 *
 * Processes user feedback memos and triggers intelligent re-execution. AI classifies feedback to determine whether new research is needed or just document regeneration. Returns proposals for user approval.
 */
export const triggerRebuild = <ThrowOnError extends boolean = false>(
  options: Options<TriggerRebuildData, ThrowOnError>
) =>
  (options.client ?? client).post<TriggerRebuildResponses, TriggerRebuildErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/rebuild',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List pending agent proposals
 *
 * Returns all pending agent proposals (agent_edit, agent_delete, agent_comment) for the mission that are awaiting user approval.
 */
export const listProposals = <ThrowOnError extends boolean = false>(
  options: Options<ListProposalsData, ThrowOnError>
) =>
  (options.client ?? client).get<ListProposalsResponses, ListProposalsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/proposals',
    ...options,
  });

/**
 * Accept an agent proposal
 *
 * Accepts the proposal and applies the suggested change.
 */
export const acceptProposal = <ThrowOnError extends boolean = false>(
  options: Options<AcceptProposalData, ThrowOnError>
) =>
  (options.client ?? client).post<AcceptProposalResponses, AcceptProposalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/proposals/{proposal_id}/accept',
    ...options,
  });

/**
 * Reject an agent proposal
 *
 * Rejects the proposal without applying changes.
 */
export const rejectProposal = <ThrowOnError extends boolean = false>(
  options: Options<RejectProposalData, ThrowOnError>
) =>
  (options.client ?? client).post<RejectProposalResponses, RejectProposalErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/proposals/{proposal_id}/reject',
    ...options,
  });

/**
 * Query task-to-document provenance
 *
 * Returns provenance records showing which tasks generated which document sections. Can filter by document path or line number to find the source task.
 */
export const getProvenance = <ThrowOnError extends boolean = false>(
  options: Options<GetProvenanceData, ThrowOnError>
) =>
  (options.client ?? client).get<GetProvenanceResponses, GetProvenanceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/mission/{mission_id}/provenance',
    ...options,
  });

/**
 * Query Knowledge Base
 *
 * DEPRECATED: Use POST /ocxp/context/discover instead.
 *
 * This endpoint will be removed in v2.0. Migrate to the new unified interface.
 *
 * Semantic search with optional project scoping and external docs fallback.
 *
 * @deprecated
 */
export const queryKnowledgeBase = <ThrowOnError extends boolean = false>(
  options: Options<QueryKnowledgeBaseData, ThrowOnError>
) =>
  (options.client ?? client).post<
    QueryKnowledgeBaseResponses,
    QueryKnowledgeBaseErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/kb/query',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Rag Knowledge Base
 *
 * DEPRECATED: Use POST /ocxp/context/discover with include_answer=true instead.
 *
 * This endpoint will be removed in v2.0. Migrate to the new unified interface.
 *
 * RAG query with LLM response and citations.
 *
 * @deprecated
 */
export const ragKnowledgeBase = <ThrowOnError extends boolean = false>(
  options: Options<RagKnowledgeBaseData, ThrowOnError>
) =>
  (options.client ?? client).post<RagKnowledgeBaseResponses, RagKnowledgeBaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/kb/rag',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List memos
 *
 * List memos for the workspace with optional filters.
 */
export const listMemos = <ThrowOnError extends boolean = false>(
  options?: Options<ListMemosData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListMemosResponses, ListMemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo',
    ...options,
  });

/**
 * Create memo
 *
 * Create a new memo (general or security finding).
 */
export const createMemo = <ThrowOnError extends boolean = false>(
  options: Options<CreateMemoData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateMemoResponses, CreateMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk delete memos
 *
 * Delete multiple memos in a single request (max 25).
 */
export const bulkDeleteMemos = <ThrowOnError extends boolean = false>(
  options: Options<BulkDeleteMemosData, ThrowOnError>
) =>
  (options.client ?? client).delete<BulkDeleteMemosResponses, BulkDeleteMemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/bulk',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk create memos
 *
 * Create multiple memos in a single request (max 25).
 */
export const bulkCreateMemos = <ThrowOnError extends boolean = false>(
  options: Options<BulkCreateMemosData, ThrowOnError>
) =>
  (options.client ?? client).post<BulkCreateMemosResponses, BulkCreateMemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/bulk',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk read memos
 *
 * Read multiple memos by IDs in a single request (max 25).
 */
export const bulkReadMemos = <ThrowOnError extends boolean = false>(
  options: Options<BulkReadMemosData, ThrowOnError>
) =>
  (options.client ?? client).post<BulkReadMemosResponses, BulkReadMemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/bulk/read',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk acknowledge memos
 *
 * Acknowledge multiple memos in a single request (max 25).
 */
export const bulkAcknowledgeMemos = <ThrowOnError extends boolean = false>(
  options: Options<BulkAcknowledgeMemosData, ThrowOnError>
) =>
  (options.client ?? client).post<
    BulkAcknowledgeMemosResponses,
    BulkAcknowledgeMemosErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/bulk/acknowledge',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk resolve memos
 *
 * Resolve multiple memos in a single request (max 25).
 */
export const bulkResolveMemos = <ThrowOnError extends boolean = false>(
  options: Options<BulkResolveMemosData, ThrowOnError>
) =>
  (options.client ?? client).post<BulkResolveMemosResponses, BulkResolveMemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/bulk/resolve',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get all memos for a project
 *
 * Load all memos for a project in a single request. This includes:
 * - Memos directly on the project (source_type=project)
 * - Memos on all missions belonging to the project (source_type=mission)
 *
 * This is much more efficient than loading memos per-mission individually.
 *
 * Use mission_status to filter which missions' memos to include (e.g., "open,in_progress"
 * to only get memos from active missions).
 */
export const getProjectMemos = <ThrowOnError extends boolean = false>(
  options: Options<GetProjectMemosData, ThrowOnError>
) =>
  (options.client ?? client).get<GetProjectMemosResponses, GetProjectMemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/project/{project_id}',
    ...options,
  });

/**
 * Delete memo
 *
 * Delete a memo permanently.
 */
export const deleteMemo = <ThrowOnError extends boolean = false>(
  options: Options<DeleteMemoData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteMemoResponses, DeleteMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/{memo_id}',
    ...options,
  });

/**
 * Get memo by ID
 *
 * Get a specific memo by its ID.
 */
export const getMemo = <ThrowOnError extends boolean = false>(
  options: Options<GetMemoData, ThrowOnError>
) =>
  (options.client ?? client).get<GetMemoResponses, GetMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/{memo_id}',
    ...options,
  });

/**
 * Update memo
 *
 * Update a memo's metadata and/or content.
 */
export const updateMemo = <ThrowOnError extends boolean = false>(
  options: Options<UpdateMemoData, ThrowOnError>
) =>
  (options.client ?? client).patch<UpdateMemoResponses, UpdateMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/{memo_id}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get memo for source
 *
 * Get memo for a specific source entity (repo, project, mission, doc).
 */
export const getMemoForSource = <ThrowOnError extends boolean = false>(
  options: Options<GetMemoForSourceData, ThrowOnError>
) =>
  (options.client ?? client).get<GetMemoForSourceResponses, GetMemoForSourceErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/source/{source_type}/{source_id}',
    ...options,
  });

/**
 * Resolve memo
 *
 * Mark a memo as resolved. Sets TTL for auto-deletion.
 */
export const resolveMemo = <ThrowOnError extends boolean = false>(
  options: Options<ResolveMemoData, ThrowOnError>
) =>
  (options.client ?? client).post<ResolveMemoResponses, ResolveMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/{memo_id}/resolve',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Acknowledge memo
 *
 * Mark a memo as acknowledged (developer has seen it).
 */
export const acknowledgeMemo = <ThrowOnError extends boolean = false>(
  options: Options<AcknowledgeMemoData, ThrowOnError>
) =>
  (options.client ?? client).post<AcknowledgeMemoResponses, AcknowledgeMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/{memo_id}/acknowledge',
    ...options,
  });

/**
 * Ignore memo
 *
 * Mark a memo as ignored (false positive or accepted risk).
 */
export const ignoreMemo = <ThrowOnError extends boolean = false>(
  options: Options<IgnoreMemoData, ThrowOnError>
) =>
  (options.client ?? client).post<IgnoreMemoResponses, IgnoreMemoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/memo/{memo_id}/ignore',
    ...options,
  });

/**
 * List workflows
 *
 * List workflows for a mission with optional status filter.
 */
export const listWorkflows = <ThrowOnError extends boolean = false>(
  options: Options<ListWorkflowsData, ThrowOnError>
) =>
  (options.client ?? client).get<ListWorkflowsResponses, ListWorkflowsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow',
    ...options,
  });

/**
 * Create workflow with tasks
 *
 * Create a new workflow with optional initial tasks. Tasks are stored as memos.
 */
export const createWorkflow = <ThrowOnError extends boolean = false>(
  options: Options<CreateWorkflowData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateWorkflowResponses, CreateWorkflowErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Delete workflow
 *
 * Delete a workflow and all its task memos.
 */
export const deleteWorkflow = <ThrowOnError extends boolean = false>(
  options: Options<DeleteWorkflowData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteWorkflowResponses, DeleteWorkflowErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}',
    ...options,
  });

/**
 * Get workflow with tasks
 *
 * Get a workflow with all its tasks in strands-compatible format.
 */
export const getWorkflow = <ThrowOnError extends boolean = false>(
  options: Options<GetWorkflowData, ThrowOnError>
) =>
  (options.client ?? client).get<GetWorkflowResponses, GetWorkflowErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}',
    ...options,
  });

/**
 * Start workflow
 *
 * Mark workflow as running.
 */
export const startWorkflow = <ThrowOnError extends boolean = false>(
  options: Options<StartWorkflowData, ThrowOnError>
) =>
  (options.client ?? client).post<StartWorkflowResponses, StartWorkflowErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/start',
    ...options,
  });

/**
 * List workflow tasks
 *
 * List all tasks for a workflow.
 */
export const listTasks = <ThrowOnError extends boolean = false>(
  options: Options<ListTasksData, ThrowOnError>
) =>
  (options.client ?? client).get<ListTasksResponses, ListTasksErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/tasks',
    ...options,
  });

/**
 * Add task to workflow
 *
 * Add a new task to an existing workflow.
 */
export const addTask = <ThrowOnError extends boolean = false>(
  options: Options<AddTaskData, ThrowOnError>
) =>
  (options.client ?? client).post<AddTaskResponses, AddTaskErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/tasks',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Bulk update tasks
 *
 * Update multiple task statuses in a single request for O(1) performance.
 */
export const bulkUpdateTasks = <ThrowOnError extends boolean = false>(
  options: Options<BulkUpdateTasksData, ThrowOnError>
) =>
  (options.client ?? client).patch<BulkUpdateTasksResponses, BulkUpdateTasksErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/tasks/bulk',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Delete task
 *
 * Delete a specific task from a workflow.
 */
export const deleteTask = <ThrowOnError extends boolean = false>(
  options: Options<DeleteTaskData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteTaskResponses, DeleteTaskErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/tasks/{task_id}',
    ...options,
  });

/**
 * Get task
 *
 * Get a specific task from a workflow.
 */
export const getTask = <ThrowOnError extends boolean = false>(
  options: Options<GetTaskData, ThrowOnError>
) =>
  (options.client ?? client).get<GetTaskResponses, GetTaskErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/tasks/{task_id}',
    ...options,
  });

/**
 * Update task
 *
 * Update a task's status, result, or error.
 */
export const updateTask = <ThrowOnError extends boolean = false>(
  options: Options<UpdateTaskData, ThrowOnError>
) =>
  (options.client ?? client).patch<UpdateTaskResponses, UpdateTaskErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/workflow/{workflow_id}/tasks/{task_id}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Start repository download
 *
 * Initiates an async download of a Git repository. Returns a job ID for status tracking. If the repository already exists (deduplicated), returns immediately with status='linked'.
 */
export const downloadRepository = <ThrowOnError extends boolean = false>(
  options: Options<DownloadRepositoryData, ThrowOnError>
) =>
  (options.client ?? client).post<
    DownloadRepositoryResponses,
    DownloadRepositoryErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/download',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get download status
 *
 * Returns the current status and progress of a repository download job.
 */
export const getRepoDownloadStatus = <ThrowOnError extends boolean = false>(
  options: Options<GetRepoDownloadStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetRepoDownloadStatusResponses,
    GetRepoDownloadStatusErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/status/{job_id}',
    ...options,
  });

/**
 * List downloaded repositories
 *
 * Returns all repositories that have been downloaded for the workspace.
 */
export const listDownloadedRepos = <ThrowOnError extends boolean = false>(
  options?: Options<ListDownloadedReposData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListDownloadedReposResponses,
    ListDownloadedReposErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/list',
    ...options,
  });

/**
 * Delete repository
 *
 * Permanently deletes a downloaded repository. Accepts UUID or owner/repo format.
 */
export const deleteRepo = <ThrowOnError extends boolean = false>(
  options: Options<DeleteRepoData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteRepoResponses, DeleteRepoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/{repo_id}',
    ...options,
  });

/**
 * Sync all repositories
 *
 * Checks all repositories for changes and triggers re-download for those with new commits. Use force=true to re-sync all regardless of changes.
 */
export const syncAllRepos = <ThrowOnError extends boolean = false>(
  options?: Options<SyncAllReposData, ThrowOnError>
) =>
  (options?.client ?? client).post<SyncAllReposResponses, SyncAllReposErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/sync-all',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });

/**
 * Get repository commit status
 *
 * Returns commit information comparing indexed version with latest GitHub commits. Shows how many commits behind and lists missing commits.
 */
export const getRepoCommits = <ThrowOnError extends boolean = false>(
  options: Options<GetRepoCommitsData, ThrowOnError>
) =>
  (options.client ?? client).get<GetRepoCommitsResponses, GetRepoCommitsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/{repo_id}/commits',
    ...options,
  });

/**
 * Sync repository
 *
 * Checks repository for changes and triggers re-download if new commits are found. Use force=true to re-sync regardless of changes.
 */
export const syncRepo = <ThrowOnError extends boolean = false>(
  options: Options<SyncRepoData, ThrowOnError>
) =>
  (options.client ?? client).post<SyncRepoResponses, SyncRepoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/repo/{repo_id}/sync',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Github Check Access
 *
 * Check GitHub repository access.
 *
 * Uses the user's stored GitHub token for private repository access.
 * Public repositories are accessible without a token.
 */
export const githubCheckAccess = <ThrowOnError extends boolean = false>(
  options: Options<GithubCheckAccessData, ThrowOnError>
) =>
  (options.client ?? client).post<
    GithubCheckAccessResponses,
    GithubCheckAccessErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/github/check-access',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Github List Branches
 *
 * List repository branches.
 *
 * Uses the user's stored GitHub token for private repository access.
 */
export const githubListBranches = <ThrowOnError extends boolean = false>(
  options: Options<GithubListBranchesData, ThrowOnError>
) =>
  (options.client ?? client).post<
    GithubListBranchesResponses,
    GithubListBranchesErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/github/branches',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Github Get Contents
 *
 * Get repository contents.
 *
 * Uses the user's stored GitHub token for private repository access.
 */
export const githubGetContents = <ThrowOnError extends boolean = false>(
  options: Options<GithubGetContentsData, ThrowOnError>
) =>
  (options.client ?? client).post<
    GithubGetContentsResponses,
    GithubGetContentsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/github/contents',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List all database configurations
 *
 * Returns all database configurations in the workspace.
 */
export const listDatabases = <ThrowOnError extends boolean = false>(
  options?: Options<ListDatabasesData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListDatabasesResponses, ListDatabasesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database',
    ...options,
  });

/**
 * Create a new database configuration
 *
 * Creates a database configuration with auto-generated UUID. Use postgres_lambda for Lambda-proxied connections.
 */
export const createDatabase = <ThrowOnError extends boolean = false>(
  options: Options<CreateDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateDatabaseResponses, CreateDatabaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * List all database configurations (alias)
 *
 * Alias for GET /ocxp/database. Returns all databases in the workspace.
 */
export const listDatabasesAlias = <ThrowOnError extends boolean = false>(
  options?: Options<ListDatabasesAliasData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListDatabasesAliasResponses,
    ListDatabasesAliasErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database/list',
    ...options,
  });

/**
 * Delete database configuration
 *
 * Permanently deletes a database configuration.
 */
export const deleteDatabase = <ThrowOnError extends boolean = false>(
  options: Options<DeleteDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteDatabaseResponses, DeleteDatabaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database/{database_id}',
    ...options,
  });

/**
 * Get database configuration details
 *
 * Returns full database configuration including connection settings and allowed tables.
 */
export const getDatabase = <ThrowOnError extends boolean = false>(
  options: Options<GetDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).get<GetDatabaseResponses, GetDatabaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database/{database_id}',
    ...options,
  });

/**
 * Update database configuration
 *
 * Updates database configuration. Only provided fields are updated.
 */
export const updateDatabase = <ThrowOnError extends boolean = false>(
  options: Options<UpdateDatabaseData, ThrowOnError>
) =>
  (options.client ?? client).put<UpdateDatabaseResponses, UpdateDatabaseErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database/{database_id}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Test database connection
 *
 * Tests the database connection and returns status.
 */
export const testDatabaseConnection = <ThrowOnError extends boolean = false>(
  options: Options<TestDatabaseConnectionData, ThrowOnError>
) =>
  (options.client ?? client).post<
    TestDatabaseConnectionResponses,
    TestDatabaseConnectionErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/database/{database_id}/test',
    ...options,
  });

/**
 * Get database schema
 *
 * Returns database schema information including tables and their metadata.
 */
export const getSchema = <ThrowOnError extends boolean = false>(
  options?: Options<GetSchemaData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetSchemaResponses, GetSchemaErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/database/schema',
    ...options,
  });

/**
 * Get sample data from table
 *
 * Returns sample rows from a specified table.
 */
export const getSample = <ThrowOnError extends boolean = false>(
  options: Options<GetSampleData, ThrowOnError>
) =>
  (options.client ?? client).get<GetSampleResponses, GetSampleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/database/sample/{table_name}',
    ...options,
  });

/**
 * List available tables
 *
 * Returns list of tables available in the database. Supports caching.
 */
export const listTables = <ThrowOnError extends boolean = false>(
  options?: Options<ListTablesData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListTablesResponses, ListTablesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/database/tables',
    ...options,
  });

/**
 * List configured databases
 *
 * Returns list of database configurations available in the workspace.
 */
export const listContextDatabases = <ThrowOnError extends boolean = false>(
  options?: Options<ListContextDatabasesData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListContextDatabasesResponses,
    ListContextDatabasesErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/database/databases',
    ...options,
  });

/**
 * Get complete database overview
 *
 * Returns complete database structure with tables, columns, and foreign keys in a single call. Supports caching.
 */
export const getDatabaseOverview = <ThrowOnError extends boolean = false>(
  options?: Options<GetDatabaseOverviewData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    GetDatabaseOverviewResponses,
    GetDatabaseOverviewErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/database/overview',
    ...options,
  });

/**
 * Get content types
 *
 * Returns all available content types (mission, context, repo, etc.) with optional item counts.
 */
export const getContentTypes = <ThrowOnError extends boolean = false>(
  options?: Options<GetContentTypesData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetContentTypesResponses, GetContentTypesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/types',
    ...options,
  });

/**
 * List content
 *
 * Lists all content items of a specific type, optionally filtered by path.
 */
export const listContent = <ThrowOnError extends boolean = false>(
  options: Options<ListContentData, ThrowOnError>
) =>
  (options.client ?? client).get<ListContentResponses, ListContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/list',
    ...options,
  });

/**
 * Query content
 *
 * Advanced query with filters on name, path, size, etc. Supports eq, ne, contains, startsWith, gt, lt operators.
 */
export const queryContent = <ThrowOnError extends boolean = false>(
  options: Options<QueryContentData, ThrowOnError>
) =>
  (options.client ?? client).post<QueryContentResponses, QueryContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/query',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Search content
 *
 * Full-text search in content names and paths. Case-insensitive.
 */
export const searchContent = <ThrowOnError extends boolean = false>(
  options: Options<SearchContentData, ThrowOnError>
) =>
  (options.client ?? client).get<SearchContentResponses, SearchContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/search',
    ...options,
  });

/**
 * Get content tree
 *
 * Returns hierarchical tree structure of content with configurable depth.
 */
export const getContentTree = <ThrowOnError extends boolean = false>(
  options: Options<GetContentTreeData, ThrowOnError>
) =>
  (options.client ?? client).get<GetContentTreeResponses, GetContentTreeErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/tree',
    ...options,
  });

/**
 * Get content statistics
 *
 * Returns file counts and sizes grouped by extension for a content path.
 */
export const getContentStats = <ThrowOnError extends boolean = false>(
  options: Options<GetContentStatsData, ThrowOnError>
) =>
  (options.client ?? client).get<GetContentStatsResponses, GetContentStatsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/stats',
    ...options,
  });

/**
 * List file versions
 *
 * Lists all versions of a file. S3 versioning must be enabled on the bucket.
 */
export const listVersions = <ThrowOnError extends boolean = false>(
  options: Options<ListVersionsData, ThrowOnError>
) =>
  (options.client ?? client).get<ListVersionsResponses, ListVersionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/{content_id}/versions',
    ...options,
  });

/**
 * Delete content
 *
 * Deletes content. Use recursive=true with confirm=true to delete directories.
 */
export const deleteContent = <ThrowOnError extends boolean = false>(
  options: Options<DeleteContentData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteContentResponses, DeleteContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/{content_id}',
    ...options,
  });

/**
 * Read content
 *
 * Reads content by type and path. Binary files are base64-encoded. Use versionId param to read a specific version.
 */
export const readContent = <ThrowOnError extends boolean = false>(
  options: Options<ReadContentData, ThrowOnError>
) =>
  (options.client ?? client).get<ReadContentResponses, ReadContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/{content_id}',
    ...options,
  });

/**
 * Write content
 *
 * Writes content to storage with robust verification. Supports ETag for optimistic locking, ifNotExists for creation-only, and wait_for_index/verify_access for synchronous KB indexing verification.
 */
export const writeContent = <ThrowOnError extends boolean = false>(
  options: Options<WriteContentData, ThrowOnError>
) =>
  (options.client ?? client).post<WriteContentResponses, WriteContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/{content_id}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Create folder
 *
 * Creates a folder with metadata.json for Bedrock KB indexing. The metadata.json serves as a folder marker (S3 doesn't have real folders) and provides KB-filterable attributes.
 */
export const createFolder = <ThrowOnError extends boolean = false>(
  options: Options<CreateFolderData, ThrowOnError>
) =>
  (options.client ?? client).post<CreateFolderResponses, CreateFolderErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/{content_type}/folder/{folder_path}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Move content
 *
 * Moves content from source to destination path. Use overwrite=true to replace existing.
 */
export const moveContent = <ThrowOnError extends boolean = false>(
  options: Options<MoveContentData, ThrowOnError>
) =>
  (options.client ?? client).post<MoveContentResponses, MoveContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/move',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Lock content
 *
 * Acquires an exclusive lock on content for the specified TTL (seconds). Stub endpoint for SDK compatibility.
 */
export const lockContent = <ThrowOnError extends boolean = false>(
  options: Options<LockContentData, ThrowOnError>
) =>
  (options.client ?? client).post<LockContentResponses, LockContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/lock',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Unlock content
 *
 * Releases an exclusive lock on content. Stub endpoint for SDK compatibility.
 */
export const unlockContent = <ThrowOnError extends boolean = false>(
  options: Options<UnlockContentData, ThrowOnError>
) =>
  (options.client ?? client).post<UnlockContentResponses, UnlockContentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/ocxp/context/unlock',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Create a new mission
 *
 * Creates a mission with optional project association and goals list.
 */
export const toolCreateMission = <ThrowOnError extends boolean = false>(
  options: Options<ToolCreateMissionData, ThrowOnError>
) =>
  (options.client ?? client).post<
    ToolCreateMissionResponses,
    ToolCreateMissionErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/mission/create',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Update mission status
 *
 * Updates mission status, progress percentage, and/or notes.
 */
export const toolUpdateMission = <ThrowOnError extends boolean = false>(
  options: Options<ToolUpdateMissionData, ThrowOnError>
) =>
  (options.client ?? client).post<
    ToolUpdateMissionResponses,
    ToolUpdateMissionErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/tools/mission/{mission_id}/update',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get mission context
 *
 * Returns mission context data optimized for AI consumption.
 */
export const getMissionContext = <ThrowOnError extends boolean = false>(
  options: Options<GetMissionContextData, ThrowOnError>
) =>
  (options.client ?? client).get<GetMissionContextResponses, GetMissionContextErrors, ThrowOnError>(
    {
      security: [{ scheme: 'bearer', type: 'http' }],
      url: '/tools/mission/{mission_id}/context',
      ...options,
    }
  );

/**
 * Login For Access Token
 *
 * OAuth2 compatible login endpoint for Swagger UI.
 *
 * Authenticates with Cognito using username/password and returns JWT tokens.
 * Use this endpoint to get a token for testing other endpoints in Swagger.
 * Returns snake_case fields per OAuth2 spec for Swagger compatibility.
 */
export const loginForAccessToken = <ThrowOnError extends boolean = false>(
  options: Options<LoginForAccessTokenData, ThrowOnError>
) =>
  (options.client ?? client).post<
    LoginForAccessTokenResponses,
    LoginForAccessTokenErrors,
    ThrowOnError
  >({
    ...urlSearchParamsBodySerializer,
    url: '/auth/token',
    ...options,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      ...options.headers,
    },
  });

/**
 * Login
 *
 * JSON login endpoint for programmatic clients.
 *
 * Authenticates with Cognito using username/password and returns JWT tokens.
 * Use /auth/token for OAuth2 form-based login (Swagger UI).
 */
export const login = <ThrowOnError extends boolean = false>(
  options: Options<LoginData, ThrowOnError>
) =>
  (options.client ?? client).post<LoginResponses, LoginErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/login',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Refresh Tokens
 *
 * Refresh access token using refresh token.
 *
 * Returns new access and ID tokens. The refresh token remains valid
 * until it expires (configured in Cognito).
 */
export const refreshTokens = <ThrowOnError extends boolean = false>(
  options: Options<RefreshTokensData, ThrowOnError>
) =>
  (options.client ?? client).post<RefreshTokensResponses, RefreshTokensErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/refresh',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Get Auth Config
 *
 * Get public configuration for clients.
 *
 * Returns the API endpoint, Brain ARN, WebSocket endpoint, and default workspace.
 * Used by Obsidian plugin and CLI to configure themselves.
 */
export const getAuthConfig = <ThrowOnError extends boolean = false>(
  options?: Options<GetAuthConfigData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetAuthConfigResponses, unknown, ThrowOnError>({
    url: '/auth/config',
    ...options,
  });

/**
 * Get Current User
 *
 * Get current authenticated user info.
 */
export const getCurrentUser = <ThrowOnError extends boolean = false>(
  options?: Options<GetCurrentUserData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetCurrentUserResponses, GetCurrentUserErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/me',
    ...options,
  });

/**
 * List Workspaces
 *
 * List workspaces for authenticated user.
 */
export const listWorkspaces = <ThrowOnError extends boolean = false>(
  options?: Options<ListWorkspacesData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListWorkspacesResponses, ListWorkspacesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/workspaces',
    ...options,
  });

/**
 * Delete Github Token
 *
 * Remove user's stored GitHub token.
 *
 * Deletes the GitHub token from DynamoDB. The user will need to
 * reconfigure their token for future GitHub operations.
 */
export const deleteGithubToken = <ThrowOnError extends boolean = false>(
  options?: Options<DeleteGithubTokenData, ThrowOnError>
) =>
  (options?.client ?? client).delete<
    DeleteGithubTokenResponses,
    DeleteGithubTokenErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/github-token',
    ...options,
  });

/**
 * Get Github Token Status
 *
 * Check if user has a GitHub token configured.
 *
 * Returns whether a token is stored and the associated GitHub username,
 * but never returns the actual token value.
 */
export const getGithubTokenStatus = <ThrowOnError extends boolean = false>(
  options?: Options<GetGithubTokenStatusData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    GetGithubTokenStatusResponses,
    GetGithubTokenStatusErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/github-token',
    ...options,
  });

/**
 * Set Github Token
 *
 * Save user's GitHub token for server-side repository operations.
 *
 * The token is stored securely in DynamoDB linked to the user's Cognito identity.
 * This enables GitHub operations without transmitting the token on every request.
 */
export const setGithubToken = <ThrowOnError extends boolean = false>(
  options: Options<SetGithubTokenData, ThrowOnError>
) =>
  (options.client ?? client).put<SetGithubTokenResponses, SetGithubTokenErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/github-token',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

/**
 * Health Check
 */
export const healthCheck2 = <ThrowOnError extends boolean = false>(
  options?: Options<HealthCheck2Data, ThrowOnError>
) =>
  (options?.client ?? client).get<HealthCheck2Responses, unknown, ThrowOnError>({
    url: '/health',
    ...options,
  });
