{"version":3,"file":"index.cjs","names":["colors","path","defaultExtensions: Extensions","simpleNameConflictResolver: NameConflictResolver","underscoreNameConflictResolver: NameConflictResolver","defaultNameConflictResolvers: NameConflictResolvers","path","ref","names: NameScopes","file","path","ctx: RenderContext","exports","Symbol","sets: Array<Set<SymbolId>>","Symbol","entries: Array<IndexEntry>","path","path","files: Array<IOutput>"],"sources":["../src/brands.ts","../src/debug.ts","../src/files/file.ts","../src/guards.ts","../src/languages/extensions.ts","../src/planner/resolvers.ts","../src/languages/resolvers.ts","../src/files/registry.ts","../src/refs/refs.ts","../src/nodes/registry.ts","../src/project/namespace.ts","../src/planner/analyzer.ts","../src/planner/planner.ts","../src/symbols/symbol.ts","../src/symbols/registry.ts","../src/project/project.ts"],"sourcesContent":["export const fileBrand = 'heyapi.file';\nexport const nodeBrand = 'heyapi.node';\nexport const symbolBrand = 'heyapi.symbol';\n","import colors from 'ansi-colors';\n// @ts-expect-error\nimport colorSupport from 'color-support';\n\ncolors.enabled = colorSupport().hasBasic;\n\nconst DEBUG_GROUPS = {\n  analyzer: colors.greenBright,\n  dsl: colors.cyanBright,\n  file: colors.yellowBright,\n  registry: colors.blueBright,\n  symbol: colors.magentaBright,\n} as const;\n\nexport function debug(message: string, group: keyof typeof DEBUG_GROUPS) {\n  const value = process.env.DEBUG;\n  if (!value) return;\n\n  const groups = value.split(',').map((x) => x.trim().toLowerCase());\n\n  if (\n    !(\n      groups.includes('*') ||\n      groups.includes('heyapi:*') ||\n      groups.includes(`heyapi:${group}`) ||\n      groups.includes(group)\n    )\n  ) {\n    return;\n  }\n\n  const color = DEBUG_GROUPS[group] ?? colors.whiteBright;\n  const prefix = color(`heyapi:${group}`);\n\n  console.debug(`${prefix} ${message}`);\n}\n","import path from 'node:path';\n\nimport type { ExportModule, ImportModule } from '../bindings';\nimport { fileBrand } from '../brands';\nimport { debug } from '../debug';\nimport type { Language } from '../languages/types';\nimport type { INode } from '../nodes/node';\nimport type { NameScopes } from '../planner/types';\nimport type { IProject } from '../project/types';\nimport type { Renderer } from '../renderer';\nimport type { IFileIn } from './types';\n\nexport class File {\n  /**\n   * Exports from this file.\n   */\n  private _exports: Array<ExportModule> = [];\n  /**\n   * File extension (e.g. `.ts`).\n   */\n  private _extension?: string;\n  /**\n   * Actual emitted file path, including extension and directories.\n   */\n  private _finalPath?: string;\n  /**\n   * Imports to this file.\n   */\n  private _imports: Array<ImportModule> = [];\n  /**\n   * Language of the file.\n   */\n  private _language?: Language;\n  /**\n   * Logical, extension-free path used for planning and routing.\n   */\n  private _logicalFilePath: string;\n  /**\n   * Base name of the file (without extension).\n   */\n  private _name?: string;\n  /**\n   * Syntax nodes contained in this file.\n   */\n  private _nodes: Array<INode> = [];\n  /**\n   * Renderer assigned to this file.\n   */\n  private _renderer?: Renderer;\n\n  /** Brand used for identifying files. */\n  readonly '~brand' = fileBrand;\n  /** All names defined in this file, including local scopes. */\n  allNames: NameScopes = new Map();\n  /** Whether this file is external to the project. */\n  external: boolean;\n  /** Unique identifier for the file. */\n  readonly id: number;\n  /** The project this file belongs to. */\n  readonly project: IProject;\n  /** Names declared at the top level of the file. */\n  topLevelNames: NameScopes = new Map();\n\n  constructor(input: IFileIn, id: number, project: IProject) {\n    this.external = input.external ?? false;\n    this.id = id;\n    if (input.language !== undefined) this._language = input.language;\n    this._logicalFilePath = input.logicalFilePath.split(path.sep).join('/');\n    if (input.name !== undefined) this._name = input.name;\n    this.project = project;\n  }\n\n  /**\n   * Exports from this file.\n   */\n  get exports(): ReadonlyArray<ExportModule> {\n    return [...this._exports];\n  }\n\n  /**\n   * Read-only accessor for the file extension.\n   */\n  get extension(): string | undefined {\n    if (this._extension) return this._extension;\n    const language = this.language;\n    const extension = language ? this.project.extensions[language] : undefined;\n    if (extension && extension[0]) return extension[0];\n    return;\n  }\n\n  /**\n   * Read-only accessor for the final emitted path.\n   *\n   * If undefined, the file has not yet been assigned a final path\n   * or is external to the project and should not be emitted.\n   */\n  get finalPath(): string | undefined {\n    if (this._finalPath) return this._finalPath;\n    const dirs = this._logicalFilePath\n      ? this._logicalFilePath.split('/').slice(0, -1)\n      : [];\n    return [...dirs, `${this.name}${this.extension ?? ''}`].join('/');\n  }\n\n  /**\n   * Imports to this file.\n   */\n  get imports(): ReadonlyArray<ImportModule> {\n    return [...this._imports];\n  }\n\n  /**\n   * Language of the file; inferred from nodes or fallback if not set explicitly.\n   */\n  get language(): Language | undefined {\n    if (this._language) return this._language;\n    if (this._nodes[0]) return this._nodes[0].language;\n    return;\n  }\n\n  /**\n   * Logical, extension-free path used for planning and routing.\n   */\n  get logicalFilePath(): string {\n    return this._logicalFilePath;\n  }\n\n  /**\n   * Base name of the file (without extension).\n   *\n   * If no name was set explicitly, it is inferred from the logical file path.\n   */\n  get name(): string {\n    if (this._name) return this._name;\n    const name = this._logicalFilePath.split('/').pop();\n    if (name) return name;\n    const message = `File ${this.toString()} has no name`;\n    debug(message, 'file');\n    throw new Error(message);\n  }\n\n  /**\n   * Syntax nodes contained in this file.\n   */\n  get nodes(): ReadonlyArray<INode> {\n    return [...this._nodes];\n  }\n\n  /**\n   * Renderer assigned to this file.\n   */\n  get renderer(): Renderer | undefined {\n    return this._renderer;\n  }\n\n  /**\n   * Add an export group to the file.\n   */\n  addExport(group: ExportModule): void {\n    this._exports.push(group);\n  }\n\n  /**\n   * Add an import group to the file.\n   */\n  addImport(group: ImportModule): void {\n    this._imports.push(group);\n  }\n\n  /**\n   * Add a syntax node to the file.\n   */\n  addNode(node: INode): void {\n    this._nodes.push(node);\n    node.file = this;\n  }\n\n  /**\n   * Sets the file extension.\n   */\n  setExtension(extension: string): void {\n    this._extension = extension;\n  }\n\n  /**\n   * Sets the final emitted path of the file.\n   */\n  setFinalPath(path: string): void {\n    this._finalPath = path;\n  }\n\n  /**\n   * Sets the language of the file.\n   */\n  setLanguage(lang: Language): void {\n    this._language = lang;\n  }\n\n  /**\n   * Sets the name of the file.\n   */\n  setName(name: string): void {\n    this._name = name;\n  }\n\n  /**\n   * Sets the renderer assigned to this file.\n   */\n  setRenderer(renderer: Renderer): void {\n    this._renderer = renderer;\n  }\n\n  /**\n   * Returns a debug‑friendly string representation identifying the file.\n   */\n  toString(): string {\n    return `[File ${this._logicalFilePath}#${this.id}]`;\n  }\n}\n","import { nodeBrand, symbolBrand } from './brands';\nimport type { INode } from './nodes/node';\nimport type { Ref } from './refs/types';\nimport type { Symbol } from './symbols/symbol';\n\nexport function isBrand(value: unknown, brand: string): value is INode {\n  if (!value || typeof value !== 'object') return false;\n  return (value as any)['~brand'] === brand;\n}\n\nexport function isNode(value: unknown): value is INode {\n  if (!value || typeof value !== 'object') return false;\n  return isBrand(value, nodeBrand);\n}\n\nexport function isNodeRef(value: Ref<unknown>): value is Ref<INode> {\n  return isBrand(value['~ref'], nodeBrand);\n}\n\nexport function isSymbol(value: unknown): value is Symbol {\n  return isBrand(value, symbolBrand);\n}\n\nexport function isSymbolRef(value: Ref<unknown>): value is Ref<Symbol> {\n  return isBrand(value['~ref'], symbolBrand);\n}\n","import type { Extensions } from './types';\n\nexport const defaultExtensions: Extensions = {\n  c: ['.c'],\n  'c#': ['.cs'],\n  'c++': ['.cpp', '.hpp'],\n  css: ['.css'],\n  dart: ['.dart'],\n  go: ['.go'],\n  haskell: ['.hs'],\n  html: ['.html'],\n  java: ['.java'],\n  javascript: ['.js', '.jsx'],\n  json: ['.json'],\n  kotlin: ['.kt'],\n  lua: ['.lua'],\n  markdown: ['.md'],\n  matlab: ['.m'],\n  perl: ['.pl'],\n  php: ['.php'],\n  python: ['.py'],\n  r: ['.r'],\n  ruby: ['.rb'],\n  rust: ['.rs'],\n  scala: ['.scala'],\n  shell: ['.sh'],\n  sql: ['.sql'],\n  swift: ['.swift'],\n  typescript: ['.ts', '.tsx'],\n  yaml: ['.yaml', '.yml'],\n};\n","import type { NameConflictResolver } from './types';\n\nexport const simpleNameConflictResolver: NameConflictResolver = ({\n  attempt,\n  baseName,\n}) => (attempt === 0 ? baseName : `${baseName}${attempt + 1}`);\n\nexport const underscoreNameConflictResolver: NameConflictResolver = ({\n  attempt,\n  baseName,\n}) => (attempt === 0 ? baseName : `${baseName}_${attempt + 1}`);\n","import { underscoreNameConflictResolver } from '../planner/resolvers';\nimport type { NameConflictResolvers } from './types';\n\nexport const defaultNameConflictResolvers: NameConflictResolvers = {\n  php: underscoreNameConflictResolver,\n  python: underscoreNameConflictResolver,\n  ruby: underscoreNameConflictResolver,\n};\n","import path from 'node:path';\n\nimport type { IProject } from '../project/types';\nimport { File } from './file';\nimport type { FileKeyArgs, IFileIn, IFileRegistry } from './types';\n\ntype FileId = number;\ntype FileKey = string;\n\nexport class FileRegistry implements IFileRegistry {\n  private _id: FileId = 0;\n  private _values: Map<FileKey, File> = new Map();\n  private readonly project: IProject;\n\n  constructor(project: IProject) {\n    this.project = project;\n  }\n\n  get(args: FileKeyArgs): File | undefined {\n    return this._values.get(this.createFileKey(args));\n  }\n\n  isRegistered(args: FileKeyArgs): boolean {\n    return this._values.has(this.createFileKey(args));\n  }\n\n  get nextId(): FileId {\n    return this._id++;\n  }\n\n  register(file: IFileIn): File {\n    const key = this.createFileKey(file);\n\n    let result = this._values.get(key);\n    if (result) {\n      if (file.name) {\n        result.setName(file.name);\n      }\n    } else {\n      result = new File(file, this.nextId, this.project);\n    }\n\n    this._values.set(key, result);\n\n    return result;\n  }\n\n  *registered(): IterableIterator<File> {\n    for (const file of this._values.values()) {\n      yield file;\n    }\n  }\n\n  private createFileKey(args: FileKeyArgs): string {\n    const logicalPath = args.logicalFilePath.split(path.sep).join('/');\n    return `${args.external ? 'ext:' : ''}${logicalPath}${args.language ? `:${args.language}` : ''}`;\n  }\n}\n","import type { FromRefs, Ref, Refs } from './types';\n\n/**\n * Wraps a single value in a Ref object.\n *\n * @example\n * ```ts\n * const r = ref(123); // { '~ref': 123 }\n * console.log(r['~ref']); // 123\n * ```\n */\nexport const ref = <T>(value: T): Ref<T> => ({ '~ref': value });\n\n/**\n * Converts a plain object to an object of Refs (deep, per property).\n *\n * @example\n * ```ts\n * const obj = { a: 1, b: \"x\" };\n * const refs = refs(obj); // { a: { '~ref': 1 }, b: { '~ref': \"x\" } }\n * ```\n */\nexport const refs = <T extends Record<string, unknown>>(obj: T): Refs<T> => {\n  const result = {} as Refs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = ref(obj[key]);\n    }\n  }\n  return result;\n};\n\n/**\n * Unwraps a single Ref object to its value.\n *\n * @example\n * ```ts\n * const r = { '~ref': 42 };\n * const n = fromRef(r); // 42\n * console.log(n); // 42\n * ```\n */\nexport const fromRef = <T extends Ref<unknown> | undefined>(\n  ref: T,\n): T extends Ref<infer U> ? U : undefined =>\n  ref?.['~ref'] as T extends Ref<infer U> ? U : undefined;\n\n/**\n * Converts an object of Refs back to a plain object (unwraps all refs).\n *\n * @example\n * ```ts\n * const refs = { a: { '~ref': 1 }, b: { '~ref': \"x\" } };\n * const plain = fromRefs(refs); // { a: 1, b: \"x\" }\n * ```\n */\nexport const fromRefs = <T extends Refs<Record<string, unknown>>>(\n  obj: T,\n): FromRefs<T> => {\n  const result = {} as FromRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = fromRef(obj[key]!) as (typeof result)[typeof key];\n    }\n  }\n  return result;\n};\n\n/**\n * Checks whether a value is a Ref object.\n *\n * @param value Value to check\n * @returns True if the value is a Ref object.\n */\nexport const isRef = <T>(value: unknown): value is Ref<T> =>\n  typeof value === 'object' && value !== null && '~ref' in value;\n","import { fromRef, ref } from '../refs/refs';\nimport type { Ref } from '../refs/types';\nimport type { INode } from './node';\nimport type { INodeRegistry } from './types';\n\nexport class NodeRegistry implements INodeRegistry {\n  private list: Array<Ref<INode | null>> = [];\n\n  add(node: INode | null): number {\n    const index = this.list.push(ref(node));\n    return index - 1;\n  }\n\n  *all(): Iterable<INode> {\n    for (const r of this.list) {\n      const node = fromRef(r);\n      if (node) yield node;\n    }\n  }\n\n  remove(index: number): void {\n    this.list[index] = ref(null);\n  }\n\n  update(index: number, node: INode | null): void {\n    this.list[index] = ref(node);\n  }\n}\n","import type { SymbolKind } from '../symbols/types';\n\n/**\n * Returns true if two declarations of given kinds\n * are allowed to share the same identifier in TypeScript.\n */\nexport function canShareName(a: SymbolKind, b: SymbolKind): boolean {\n  // same-kind always valid for interfaces (merging)\n  if (a === 'interface' && b === 'interface') return true;\n\n  // type vs interface merges\n  if (\n    (a === 'interface' && b === 'type') ||\n    (a === 'type' && b === 'interface')\n  ) {\n    return false; // TypeScript does NOT merge type-alias with interface.\n  }\n\n  // type vs type = conflict\n  if (a === 'type' && b === 'type') return false;\n\n  // interface vs class = allowed (declare-merge)\n  if (\n    (a === 'interface' && b === 'class') ||\n    (a === 'class' && b === 'interface')\n  ) {\n    return true;\n  }\n\n  // enum vs namespace = allowed (merges into value+type)\n  if (\n    (a === 'enum' && b === 'namespace') ||\n    (a === 'namespace' && b === 'enum')\n  ) {\n    return true;\n  }\n\n  // class vs namespace = allowed\n  if (\n    (a === 'class' && b === 'namespace') ||\n    (a === 'namespace' && b === 'class')\n  ) {\n    return true;\n  }\n\n  // namespace vs namespace = allowed (merging)\n  if (a === 'namespace' && b === 'namespace') return true;\n\n  // enum vs enum = conflict IF values conflict (TypeScript flags duplicates)\n  if (a === 'enum' && b === 'enum') return false;\n\n  // function and namespace merge (namespace can augment function)\n  if (\n    (a === 'function' && b === 'namespace') ||\n    (a === 'namespace' && b === 'function')\n  ) {\n    return true;\n  }\n\n  // these collide with each other in the value namespace\n  const valueKinds = new Set<SymbolKind>(['class', 'enum', 'function', 'var']);\n\n  const aInValue = valueKinds.has(a);\n  const bInValue = valueKinds.has(b);\n\n  if (aInValue && bInValue) return false;\n\n  // type-only declarations do not collide with value-only declarations\n  const typeKinds = new Set<SymbolKind>(['interface', 'type']);\n  const aInType = typeKinds.has(a);\n  const bInType = typeKinds.has(b);\n\n  // if one is type-only and the other is value-only, they do NOT collide\n  if (aInType !== bInType) return true;\n\n  return true;\n}\n","import { isNodeRef, isSymbolRef } from '../guards';\nimport type { INode } from '../nodes/node';\nimport { fromRef, isRef, ref } from '../refs/refs';\nimport type { Ref } from '../refs/types';\nimport type { Symbol } from '../symbols/symbol';\nimport type { IAnalysisContext, Input, NameScopes, Scope } from './types';\n\nconst createScope = (parent?: Scope): Scope => ({\n  children: [],\n  localNames: new Map(),\n  parent,\n  symbols: [],\n});\n\nexport class AnalysisContext implements IAnalysisContext {\n  scopes: Scope = createScope();\n  symbol?: Symbol;\n  scope: Scope = this.scopes;\n\n  constructor(symbol?: Symbol) {\n    this.symbol = symbol;\n  }\n\n  addDependency(symbol: Ref<Symbol>): void {\n    if (this.symbol !== fromRef(symbol)) {\n      this.scope.symbols.push(symbol);\n    }\n  }\n\n  analyze(input: Input): void {\n    const v = isRef(input) ? input : ref(input);\n    if (isSymbolRef(v)) {\n      this.addDependency(v);\n    } else if (isNodeRef(v)) {\n      fromRef(v).analyze(this);\n    }\n  }\n\n  localNames(scope: Scope): NameScopes {\n    const names: NameScopes = new Map();\n    for (const [name, kinds] of scope.localNames) {\n      names.set(name, new Set(kinds));\n    }\n    if (scope.parent) {\n      const parentNames = this.localNames(scope.parent);\n      for (const [name, kinds] of parentNames) {\n        if (!names.has(name)) {\n          names.set(name, kinds);\n        } else {\n          const existingKinds = names.get(name)!;\n          for (const kind of kinds) {\n            existingKinds.add(kind);\n          }\n        }\n      }\n    }\n    return names;\n  }\n\n  popScope(): void {\n    this.scope = this.scope.parent ?? this.scope;\n  }\n\n  pushScope(): void {\n    const scope = createScope(this.scope);\n    this.scope.children.push(scope);\n    this.scope = scope;\n  }\n\n  walkScopes(\n    callback: (symbol: Ref<Symbol>, scope: Scope) => void,\n    scope: Scope = this.scopes,\n  ): void {\n    this.scope = scope;\n    for (const symbol of scope.symbols) {\n      callback(symbol, scope);\n    }\n    for (const child of scope.children) {\n      scope = child;\n      this.walkScopes(callback, scope);\n    }\n    this.scope = this.scopes;\n  }\n}\n\nexport class Analyzer {\n  private nodeCache = new WeakMap<INode, AnalysisContext>();\n\n  analyzeNode(node: INode): AnalysisContext {\n    const cached = this.nodeCache.get(node);\n    if (cached) return cached;\n\n    const ctx = new AnalysisContext(node.symbol);\n    node.analyze(ctx);\n\n    this.nodeCache.set(node, ctx);\n    return ctx;\n  }\n\n  analyze(\n    nodes: Iterable<INode>,\n    callback?: (ctx: AnalysisContext, node: INode) => void,\n  ): void {\n    for (const node of nodes) {\n      const ctx = this.analyzeNode(node);\n      callback?.(ctx, node);\n    }\n  }\n}\n","import path from 'node:path';\n\nimport type { ExportModule, ImportModule } from '../bindings';\nimport type { IProjectRenderMeta } from '../extensions';\nimport type { File } from '../files/file';\nimport type { IFileIn } from '../files/types';\nimport { canShareName } from '../project/namespace';\nimport type { IProject } from '../project/types';\nimport { fromRef } from '../refs/refs';\nimport type { RenderContext } from '../renderer';\nimport type { Symbol } from '../symbols/symbol';\nimport type { SymbolKind } from '../symbols/types';\nimport type { AnalysisContext } from './analyzer';\nimport { Analyzer } from './analyzer';\nimport type { AssignOptions, NameScopes } from './types';\n\nconst isTypeOnlyKind = (kind: SymbolKind) =>\n  kind === 'type' || kind === 'interface';\n\nexport class Planner {\n  private readonly analyzer = new Analyzer();\n  private readonly cacheResolvedNames = new Set<number>();\n  private readonly project: IProject;\n\n  constructor(project: IProject) {\n    this.project = project;\n  }\n\n  /**\n   * Executes the planning phase for the project.\n   */\n  plan(meta?: IProjectRenderMeta) {\n    this.cacheResolvedNames.clear();\n    this.allocateFiles();\n    this.assignLocalNames();\n    this.resolveFilePaths(meta);\n    this.planExports();\n    this.planImports();\n  }\n\n  /**\n   * Creates and assigns a file to every node, re-export,\n   * and external dependency.\n   */\n  private allocateFiles(): void {\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const symbol = node.symbol;\n      if (!symbol) return;\n\n      const file = this.project.files.register(this.symbolToFileIn(symbol));\n      file.addNode(node);\n      symbol.setFile(file);\n      for (const exportFrom of symbol.exportFrom) {\n        this.project.files.register({\n          external: false,\n          language: file.language,\n          logicalFilePath: exportFrom,\n        });\n      }\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        if (dep.external && dep.isCanonical && !dep.file) {\n          const file = this.project.files.register(this.symbolToFileIn(dep));\n          dep.setFile(file);\n        }\n      });\n    });\n  }\n\n  /**\n   * Assigns final names to all symbols.\n   *\n   * First assigns top-level (file-scoped) symbol names, then local symbols.\n   */\n  private assignLocalNames(): void {\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const symbol = node.symbol;\n      if (!symbol) return;\n      this.assignTopLevelName(symbol, ctx);\n    });\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const file = node.file;\n      if (!file) return;\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        // top-level or external symbol\n        if (dep.file) return;\n        this.assignLocalName(dep, ctx, {\n          scopesToUpdate: [file.allNames],\n        });\n      });\n    });\n  }\n\n  /**\n   * Resolves and sets final file paths for all non-external files. Attaches renderers.\n   *\n   * Uses the project's fileName function if provided, otherwise uses the file's current name.\n   *\n   * Resolves final paths relative to the project's root directory.\n   */\n  private resolveFilePaths(meta?: IProjectRenderMeta): void {\n    for (const file of this.project.files.registered()) {\n      if (file.external) continue;\n      const finalName = this.project.fileName?.(file.name) || file.name;\n      file.setName(finalName);\n      const finalPath = file.finalPath;\n      if (finalPath) {\n        file.setFinalPath(path.resolve(this.project.root, finalPath));\n      }\n      const ctx: RenderContext = { file, meta, project: this.project };\n      const renderer = this.project.renderers.find((r) => r.supports(ctx));\n      if (renderer) file.setRenderer(renderer);\n    }\n  }\n\n  /**\n   * Plans exports by analyzing all exported symbols.\n   *\n   * Registers re-export targets as files and creates new exported symbols for them.\n   *\n   * Assigns names to re-exported symbols and collects re-export metadata,\n   * distinguishing type-only exports based on symbol kinds.\n   */\n  private planExports(): void {\n    const seenByFile = new Map<\n      File,\n      Map<string, { kinds: Set<SymbolKind>; symbol: Symbol }>\n    >();\n    const sourceFile = new Map<number, File>();\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      if (!node.exported) return;\n\n      const symbol = node.symbol;\n      if (!symbol) return;\n\n      const file = node.file;\n      if (!file) return;\n\n      for (const exportFrom of symbol.exportFrom) {\n        const target = this.project.files.register({\n          external: false,\n          language: node.language,\n          logicalFilePath: exportFrom,\n        });\n        if (target.id === file.id) continue;\n\n        let fileMap = seenByFile.get(target);\n        if (!fileMap) {\n          fileMap = new Map();\n          seenByFile.set(target, fileMap);\n        }\n\n        const exp = this.project.symbols.register({\n          exported: true,\n          external: symbol.external,\n          importKind: symbol.importKind,\n          kind: symbol.kind,\n          name: symbol.finalName,\n        });\n        exp.setFile(target);\n        sourceFile.set(exp.id, file);\n        this.assignTopLevelName(exp, ctx);\n\n        let entry = fileMap.get(exp.finalName);\n        if (!entry) {\n          entry = { kinds: new Set(), symbol: exp };\n          fileMap.set(exp.finalName, entry);\n        }\n        entry.kinds.add(exp.kind);\n      }\n    });\n\n    for (const [file, fileMap] of seenByFile) {\n      const exports = new Map<File, ExportModule>();\n      for (const [, entry] of fileMap) {\n        const source = sourceFile.get(entry.symbol.id)!;\n        let exp = exports.get(source);\n        if (!exp) {\n          exp = {\n            canExportAll: true,\n            exports: [],\n            from: source,\n            isTypeOnly: true,\n          };\n        }\n        const isTypeOnly = [...entry.kinds].every((kind) =>\n          isTypeOnlyKind(kind),\n        );\n        const exportedName = entry.symbol.finalName;\n        exp.exports.push({\n          exportedName,\n          isTypeOnly,\n          kind: entry.symbol.importKind,\n          sourceName: entry.symbol.name,\n        });\n        if (entry.symbol.name !== entry.symbol.finalName) {\n          exp.canExportAll = false;\n        }\n        if (!isTypeOnly) {\n          exp.isTypeOnly = false;\n        }\n        exports.set(source, exp);\n      }\n      for (const [, exp] of exports) {\n        file.addExport(exp);\n      }\n    }\n  }\n\n  /**\n   * Plans imports by analyzing symbol dependencies across files.\n   *\n   * For external dependencies, assigns top-level names.\n   *\n   * Creates or reuses import symbols for dependencies from other files,\n   * assigning names and updating import metadata including type-only flags.\n   */\n  private planImports(): void {\n    const seenByFile = new Map<\n      File,\n      Map<\n        string,\n        {\n          dep: Symbol;\n          kinds: Set<SymbolKind>;\n          symbol: Symbol;\n        }\n      >\n    >();\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx) => {\n      const symbol = ctx.symbol;\n      if (!symbol) return;\n\n      const file = symbol.file;\n      if (!file) return;\n\n      let fileMap = seenByFile.get(file);\n      if (!fileMap) {\n        fileMap = new Map();\n        seenByFile.set(file, fileMap);\n      }\n\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        if (!dep.file || dep.file.id === file.id) return;\n\n        if (dep.external) {\n          this.assignTopLevelName(dep, ctx);\n        }\n\n        const fromFileId = dep.file.id;\n        const importedName = dep.finalName;\n        const isTypeOnly = isTypeOnlyKind(dep.kind);\n        const kind = dep.importKind;\n        const key = `${fromFileId}|${importedName}|${kind}|${isTypeOnly}`;\n\n        let entry = fileMap.get(key);\n        if (!entry) {\n          const imp = this.project.symbols.register({\n            exported: dep.exported,\n            external: dep.external,\n            importKind: dep.importKind,\n            kind: dep.kind,\n            name: dep.finalName,\n          });\n          imp.setFile(file);\n          this.assignTopLevelName(imp, ctx, {\n            scope: imp.file!.allNames,\n          });\n          entry = {\n            dep,\n            kinds: new Set(),\n            symbol: imp,\n          };\n          fileMap.set(key, entry);\n          entry.kinds.add(imp.kind);\n        }\n\n        dependency['~ref'] = entry.symbol;\n      });\n    });\n\n    for (const [file, fileMap] of seenByFile) {\n      const imports = new Map<File, ImportModule>();\n      for (const [, entry] of fileMap) {\n        const source = entry.dep.file!;\n        let imp = imports.get(source);\n        if (!imp) {\n          imp = {\n            from: source,\n            imports: [],\n            isTypeOnly: true,\n          };\n        }\n        const isTypeOnly = [...entry.kinds].every((kind) =>\n          isTypeOnlyKind(kind),\n        );\n        if (entry.symbol.importKind === 'namespace') {\n          imp.imports = [];\n          imp.namespaceImport = entry.symbol.finalName;\n        } else {\n          imp.imports.push({\n            isTypeOnly,\n            kind: entry.symbol.importKind,\n            localName: entry.symbol.finalName,\n            sourceName: entry.dep.finalName,\n          });\n        }\n        if (!isTypeOnly) {\n          imp.isTypeOnly = false;\n        }\n        imports.set(source, imp);\n      }\n      for (const [, imp] of imports) {\n        file.addImport(imp);\n      }\n    }\n  }\n\n  /**\n   * Assigns the final name to a top-level (file-scoped) symbol.\n   *\n   * Uses the symbol's file top-level names as the default scope,\n   * and updates all relevant name scopes including the file's allNames and local scopes.\n   *\n   * Supports optional overrides for the naming scope and scopes to update.\n   */\n  private assignTopLevelName(\n    symbol: Symbol,\n    ctx: AnalysisContext,\n    options?: Partial<AssignOptions>,\n  ): void {\n    if (!symbol.file) return;\n    this.assignSymbolName(symbol, {\n      scope: options?.scope ?? symbol.file.topLevelNames,\n      scopesToUpdate: [\n        symbol.file.allNames,\n        ctx.scopes.localNames,\n        ...(options?.scopesToUpdate ?? []),\n      ],\n    });\n  }\n\n  /**\n   * Assigns the final name to a non-top-level (local) symbol.\n   *\n   * Uses the provided scope or derives it from the current analysis context's local names.\n   *\n   * Updates all provided name scopes accordingly.\n   */\n  private assignLocalName(\n    symbol: Symbol,\n    ctx: AnalysisContext,\n    options: Pick<Partial<AssignOptions>, 'scope'> &\n      Pick<AssignOptions, 'scopesToUpdate'>,\n  ): void {\n    this.assignSymbolName(symbol, {\n      scope: options.scope ?? ctx.localNames(ctx.scope),\n      scopesToUpdate: options.scopesToUpdate,\n    });\n  }\n\n  /**\n   * Assigns the final name to a symbol within the provided name scope.\n   *\n   * Resolves name conflicts until a unique name is found.\n   *\n   * Updates all specified name scopes with the assigned final name.\n   */\n  private assignSymbolName(symbol: Symbol, options: AssignOptions): void {\n    if (this.cacheResolvedNames.has(symbol.id)) return;\n\n    const baseName = symbol.name;\n    let finalName = symbol.nameSanitizer?.(baseName) ?? baseName;\n    let attempt = 1;\n\n    while (true) {\n      const kinds = [...(options.scope.get(finalName) ?? [])];\n\n      const ok = kinds.every((kind) => canShareName(symbol.kind, kind));\n      if (ok) break;\n\n      const language = symbol.node?.language || symbol.file?.language;\n      const resolver =\n        (language ? this.project.nameConflictResolvers[language] : undefined) ??\n        this.project.defaultNameConflictResolver;\n      const resolvedName = resolver({ attempt, baseName });\n      if (!resolvedName) {\n        throw new Error(`Unresolvable name conflict: ${symbol.toString()}`);\n      }\n\n      finalName = symbol.nameSanitizer?.(resolvedName) ?? resolvedName;\n      attempt = attempt + 1;\n    }\n\n    symbol.setFinalName(finalName);\n    this.cacheResolvedNames.add(symbol.id);\n    const updateScopes = [options.scope, ...options.scopesToUpdate];\n    for (const scope of updateScopes) {\n      this.updateScope(symbol, scope);\n    }\n  }\n\n  /**\n   * Updates the provided name scope with the symbol's final name and kind.\n   *\n   * Ensures the name scope tracks all kinds associated with a given name.\n   */\n  private updateScope(symbol: Symbol, scope: NameScopes): void {\n    const name = symbol.finalName;\n    const cache = scope.get(name) ?? new Set<SymbolKind>();\n    cache.add(symbol.kind);\n    scope.set(name, cache);\n  }\n\n  private symbolToFileIn(symbol: Symbol): IFileIn {\n    return {\n      external: Boolean(symbol.external),\n      language: symbol.node?.language,\n      logicalFilePath:\n        symbol.external ||\n        symbol.getFilePath?.(symbol) ||\n        this.project.defaultFileName,\n    } satisfies IFileIn;\n  }\n}\n","import { symbolBrand } from '../brands';\nimport { debug } from '../debug';\nimport type { ISymbolMeta } from '../extensions';\nimport type { File } from '../files/file';\nimport type { INode } from '../nodes/node';\nimport type {\n  BindingKind,\n  ISymbolIn,\n  SymbolKind,\n  SymbolNameSanitizer,\n} from './types';\n\nexport class Symbol {\n  /**\n   * Canonical symbol this stub resolves to, if any.\n   *\n   * Stubs created during DSL construction may later be associated\n   * with a fully registered symbol. Once set, all property lookups\n   * should defer to the canonical symbol.\n   */\n  private _canonical?: Symbol;\n  /**\n   * True if this symbol is exported from its defining file.\n   *\n   * @default false\n   */\n  private _exported: boolean;\n  /**\n   * Names of files (without extension) from which this symbol is re-exported.\n   *\n   * @default []\n   */\n  private _exportFrom: ReadonlyArray<string>;\n  /**\n   * External module name if this symbol is imported from a module not managed\n   * by the project (e.g. \"zod\", \"lodash\").\n   *\n   * @default undefined\n   */\n  private _external?: string;\n  /**\n   * The file this symbol is ultimately emitted into.\n   *\n   * Only top-level symbols have an assigned file.\n   */\n  private _file?: File;\n  /**\n   * The alias-resolved, conflict-free emitted name.\n   */\n  private _finalName?: string;\n  /**\n   * Custom strategy to determine file output path.\n   *\n   * @returns The file path to output the symbol to, or undefined to fallback to default behavior.\n   */\n  private _getFilePath?: (symbol: Symbol) => string | undefined;\n  /**\n   * How this symbol should be imported (namespace/default/named).\n   *\n   * @default 'named'\n   */\n  private _importKind: BindingKind;\n  /**\n   * Kind of symbol (class, type, alias, etc.).\n   *\n   * @default 'var'\n   */\n  private _kind: SymbolKind;\n  /**\n   * Arbitrary user metadata.\n   *\n   * @default undefined\n   */\n  private _meta?: ISymbolMeta;\n  /**\n   * Intended user-facing name before conflict resolution.\n   *\n   * @example \"UserModel\"\n   */\n  private _name: string;\n  /**\n   * Optional function to sanitize the symbol name.\n   *\n   * @default undefined\n   */\n  private _nameSanitizer?: SymbolNameSanitizer;\n  /**\n   * Node that defines this symbol.\n   */\n  private _node?: INode;\n\n  /** Brand used for identifying symbols. */\n  readonly '~brand' = symbolBrand;\n  /** Globally unique, stable symbol ID. */\n  readonly id: number;\n\n  constructor(input: ISymbolIn, id: number) {\n    this._exported = input.exported ?? false;\n    this._exportFrom = input.exportFrom ?? [];\n    this._external = input.external;\n    this._getFilePath = input.getFilePath;\n    this.id = id;\n    this._importKind = input.importKind ?? 'named';\n    this._kind = input.kind ?? 'var';\n    this._meta = input.meta;\n    this._name = input.name;\n  }\n\n  /**\n   * Returns the canonical symbol for this instance.\n   *\n   * If this symbol was created as a stub, this getter returns\n   * the fully registered canonical symbol. Otherwise, it returns\n   * the symbol itself.\n   */\n  get canonical(): Symbol {\n    return this._canonical ?? this;\n  }\n\n  /**\n   * Indicates whether this symbol is exported from its defining file.\n   */\n  get exported(): boolean {\n    return this.canonical._exported;\n  }\n\n  /**\n   * Names of files (without extension) that re-export this symbol.\n   */\n  get exportFrom(): ReadonlyArray<string> {\n    return this.canonical._exportFrom;\n  }\n\n  /**\n   * External module from which this symbol originates, if any.\n   */\n  get external(): string | undefined {\n    return this.canonical._external;\n  }\n\n  /**\n   * Read‑only accessor for the assigned output file.\n   *\n   * Only top-level symbols have an assigned file.\n   */\n  get file(): File | undefined {\n    return this.canonical._file;\n  }\n\n  /**\n   * Read‑only accessor for the resolved final emitted name.\n   */\n  get finalName(): string {\n    if (!this.canonical._finalName) {\n      const message = `Symbol finalName has not been resolved yet for ${this.canonical.toString()}`;\n      debug(message, 'symbol');\n      throw new Error(message);\n    }\n    return this.canonical._finalName;\n  }\n\n  /**\n   * Custom file path resolver, if provided.\n   */\n  get getFilePath(): ((symbol: Symbol) => string | undefined) | undefined {\n    return this.canonical._getFilePath;\n  }\n\n  /**\n   * How this symbol should be imported (named/default/namespace).\n   */\n  get importKind(): BindingKind {\n    return this.canonical._importKind;\n  }\n\n  /**\n   * Indicates whether this is a canonical symbol (not a stub).\n   */\n  get isCanonical(): boolean {\n    return !this._canonical || this._canonical === this;\n  }\n\n  /**\n   * The symbol's kind (class, type, alias, variable, etc.).\n   */\n  get kind(): SymbolKind {\n    return this.canonical._kind;\n  }\n\n  /**\n   * Arbitrary user‑provided metadata associated with this symbol.\n   */\n  get meta(): ISymbolMeta | undefined {\n    return this.canonical._meta;\n  }\n\n  /**\n   * User-intended name before aliasing or conflict resolution.\n   */\n  get name(): string {\n    return this.canonical._name;\n  }\n\n  /**\n   * Optional function to sanitize the symbol name.\n   */\n  get nameSanitizer(): SymbolNameSanitizer | undefined {\n    return this.canonical._nameSanitizer;\n  }\n\n  /**\n   * Read‑only accessor for the defining node.\n   */\n  get node(): INode | undefined {\n    return this.canonical._node;\n  }\n\n  /**\n   * Marks this symbol as a stub and assigns its canonical symbol.\n   *\n   * After calling this, all semantic queries (name, kind, file,\n   * meta, etc.) should reflect the canonical symbol's values.\n   *\n   * @param symbol — The canonical symbol this stub should resolve to.\n   */\n  setCanonical(symbol: Symbol): void {\n    this._canonical = symbol;\n  }\n\n  /**\n   * Marks the symbol as exported from its file.\n   *\n   * @param exported — Whether the symbol is exported.\n   */\n  setExported(exported: boolean): void {\n    this.assertCanonical();\n    this._exported = exported;\n  }\n\n  /**\n   * Records file names that re‑export this symbol.\n   *\n   * @param list — Source files re‑exporting this symbol.\n   */\n  setExportFrom(list: ReadonlyArray<string>): void {\n    this.assertCanonical();\n    this._exportFrom = list;\n  }\n\n  /**\n   * Assigns the output file this symbol will be emitted into.\n   *\n   * This may only be set once.\n   */\n  setFile(file: File): void {\n    this.assertCanonical();\n    if (this._file && this._file !== file) {\n      const message = `Symbol ${this.canonical.toString()} is already assigned to a different file.`;\n      debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._file = file;\n  }\n\n  /**\n   * Assigns the conflict‑resolved final local name for this symbol.\n   *\n   * This may only be set once.\n   */\n  setFinalName(name: string): void {\n    this.assertCanonical();\n    if (this._finalName && this._finalName !== name) {\n      const message = `Symbol finalName has already been resolved for ${this.canonical.toString()}.`;\n      debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._finalName = name;\n  }\n\n  /**\n   * Sets how this symbol should be imported.\n   *\n   * @param kind — The import strategy (named/default/namespace).\n   */\n  setImportKind(kind: BindingKind): void {\n    this.assertCanonical();\n    this._importKind = kind;\n  }\n\n  /**\n   * Sets the symbol's kind (class, type, alias, variable, etc.).\n   *\n   * @param kind — The new symbol kind.\n   */\n  setKind(kind: SymbolKind): void {\n    this.assertCanonical();\n    this._kind = kind;\n  }\n\n  /**\n   * Updates the intended user‑facing name for this symbol.\n   *\n   * @param name — The new name.\n   */\n  setName(name: string): void {\n    this.assertCanonical();\n    this._name = name;\n  }\n\n  /**\n   * Sets a custom function to sanitize the symbol's name.\n   *\n   * @param fn — The name sanitizer function to apply.\n   */\n  setNameSanitizer(fn: SymbolNameSanitizer): void {\n    this.assertCanonical();\n    this._nameSanitizer = fn;\n  }\n\n  /**\n   * Binds the node that defines this symbol.\n   *\n   * This may only be set once.\n   */\n  setNode(node: INode): void {\n    this.assertCanonical();\n    if (this._node && this._node !== node) {\n      const message = `Symbol ${this.canonical.toString()} is already bound to a different node.`;\n      debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._node = node;\n    node.symbol = this;\n  }\n\n  /**\n   * Returns a debug‑friendly string representation identifying the symbol.\n   */\n  toString(): string {\n    return `[Symbol ${this.name}#${this.id}]`;\n  }\n\n  /**\n   * Ensures this symbol is canonical before allowing mutation.\n   *\n   * A symbol that has been marked as a stub (i.e., its `_canonical` points\n   * to a different symbol) may not be mutated. This guard throws an error\n   * if any setter attempts to modify a stub, preventing accidental writes\n   * to non‑canonical instances.\n   *\n   * @throws {Error} If the symbol is a stub and is being mutated.\n   */\n  private assertCanonical(): void {\n    if (this._canonical && this._canonical !== this) {\n      const message = `Illegal mutation of stub symbol ${this.toString()} → canonical: ${this._canonical.toString()}`;\n      debug(message, 'symbol');\n      throw new Error(message);\n    }\n  }\n}\n","import type { ISymbolMeta } from '../extensions';\nimport { Symbol } from './symbol';\nimport type { ISymbolIdentifier, ISymbolIn, ISymbolRegistry } from './types';\n\ntype IndexEntry = [string, unknown];\ntype IndexKeySpace = ReadonlyArray<IndexEntry>;\ntype QueryCacheKey = string;\ntype SymbolId = number;\n\nexport class SymbolRegistry implements ISymbolRegistry {\n  private _id: SymbolId = 0;\n  private _indices: Map<IndexEntry[0], Map<IndexEntry[1], Set<SymbolId>>> =\n    new Map();\n  private _queryCache: Map<QueryCacheKey, ReadonlyArray<SymbolId>> = new Map();\n  private _queryCacheDependencies: Map<QueryCacheKey, Set<QueryCacheKey>> =\n    new Map();\n  private _registered: Set<SymbolId> = new Set();\n  private _stubs: Set<SymbolId> = new Set();\n  private _stubCache: Map<QueryCacheKey, SymbolId> = new Map();\n  private _values: Map<SymbolId, Symbol> = new Map();\n\n  get(identifier: ISymbolIdentifier): Symbol | undefined {\n    return typeof identifier === 'number'\n      ? this._values.get(identifier)\n      : this.query(identifier)[0];\n  }\n\n  isRegistered(identifier: ISymbolIdentifier): boolean {\n    const symbol = this.get(identifier);\n    return symbol ? this._registered.has(symbol.id) : false;\n  }\n\n  get nextId(): SymbolId {\n    return this._id++;\n  }\n\n  query(filter: ISymbolMeta): ReadonlyArray<Symbol> {\n    const cacheKey = this.buildCacheKey(filter);\n    const cachedIds = this._queryCache.get(cacheKey);\n    if (cachedIds) {\n      return cachedIds.map((symbolId) => this._values.get(symbolId)!);\n    }\n    const sets: Array<Set<SymbolId>> = [];\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    const cacheDependencies = new Set<QueryCacheKey>();\n    let missed = false;\n    for (const indexEntry of indexKeySpace) {\n      cacheDependencies.add(this.serializeIndexEntry(indexEntry));\n      const values = this._indices.get(indexEntry[0]);\n      if (!values) {\n        missed = true;\n        break;\n      }\n      const set = values.get(indexEntry[1]);\n      if (!set) {\n        missed = true;\n        break;\n      }\n      sets.push(set);\n    }\n    if (missed || !sets.length) {\n      this._queryCacheDependencies.set(cacheKey, cacheDependencies);\n      this._queryCache.set(cacheKey, []);\n      return [];\n    }\n    let result = new Set(sets[0]);\n    for (const set of sets.slice(1)) {\n      result = new Set([...result].filter((symbolId) => set.has(symbolId)));\n    }\n    const resultIds = [...result];\n    this._queryCacheDependencies.set(cacheKey, cacheDependencies);\n    this._queryCache.set(cacheKey, resultIds);\n    return resultIds.map((symbolId) => this._values.get(symbolId)!);\n  }\n\n  reference(meta: ISymbolMeta): Symbol {\n    const [registered] = this.query(meta);\n    if (registered) return registered;\n\n    const cacheKey = this.buildCacheKey(meta);\n    const cachedId = this._stubCache.get(cacheKey);\n    if (cachedId !== undefined) return this._values.get(cachedId)!;\n\n    const stub = new Symbol({ meta, name: '' }, this.nextId);\n\n    this._values.set(stub.id, stub);\n    this._stubs.add(stub.id);\n    this._stubCache.set(cacheKey, stub.id);\n    return stub;\n  }\n\n  register(symbol: ISymbolIn): Symbol {\n    const result = new Symbol(symbol, this.nextId);\n\n    this._values.set(result.id, result);\n    this._registered.add(result.id);\n\n    if (result.meta) {\n      const indexKeySpace = this.buildIndexKeySpace(result.meta);\n      this.indexSymbol(result.id, indexKeySpace);\n      this.invalidateCache(indexKeySpace);\n      this.replaceStubs(result, indexKeySpace);\n    }\n\n    return result;\n  }\n\n  *registered(): IterableIterator<Symbol> {\n    for (const id of this._registered.values()) {\n      yield this._values.get(id)!;\n    }\n  }\n\n  private buildCacheKey(filter: ISymbolMeta): QueryCacheKey {\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    return indexKeySpace\n      .map((indexEntry) => this.serializeIndexEntry(indexEntry))\n      .sort() // ensure order-insensitivity\n      .join('|');\n  }\n\n  private buildIndexKeySpace(meta: ISymbolMeta, prefix = ''): IndexKeySpace {\n    const entries: Array<IndexEntry> = [];\n    for (const [key, value] of Object.entries(meta)) {\n      const path = prefix ? `${prefix}.${key}` : key;\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        entries.push(...this.buildIndexKeySpace(value as ISymbolMeta, path));\n      } else {\n        entries.push([path, value]);\n      }\n    }\n    return entries;\n  }\n\n  private indexSymbol(symbolId: SymbolId, indexKeySpace: IndexKeySpace): void {\n    for (const [key, value] of indexKeySpace) {\n      if (!this._indices.has(key)) this._indices.set(key, new Map());\n      const values = this._indices.get(key)!;\n      const set = values.get(value) ?? new Set();\n      set.add(symbolId);\n      values.set(value, set);\n    }\n  }\n\n  private invalidateCache(indexKeySpace: IndexKeySpace): void {\n    const changed = indexKeySpace.map((indexEntry) =>\n      this.serializeIndexEntry(indexEntry),\n    );\n    for (const [\n      cacheKey,\n      cacheDependencies,\n    ] of this._queryCacheDependencies.entries()) {\n      for (const key of changed) {\n        if (cacheDependencies.has(key)) {\n          this._queryCacheDependencies.delete(cacheKey);\n          this._queryCache.delete(cacheKey);\n          break;\n        }\n      }\n    }\n  }\n\n  private isSubset(sub: IndexKeySpace, sup: IndexKeySpace): boolean {\n    const supMap = new Map(sup);\n    for (const [key, value] of sub) {\n      if (!supMap.has(key) || supMap.get(key) !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private replaceStubs(symbol: Symbol, indexKeySpace: IndexKeySpace): void {\n    for (const stubId of this._stubs.values()) {\n      const stub = this._values.get(stubId);\n      if (\n        stub?.meta &&\n        this.isSubset(this.buildIndexKeySpace(stub.meta), indexKeySpace)\n      ) {\n        const cacheKey = this.buildCacheKey(stub.meta);\n        this._stubCache.delete(cacheKey);\n        this._stubs.delete(stubId);\n        stub.setCanonical(symbol);\n      }\n    }\n  }\n\n  private serializeIndexEntry(indexEntry: IndexEntry): string {\n    return `${indexEntry[0]}:${JSON.stringify(indexEntry[1])}`;\n  }\n}\n","import path from 'node:path';\n\nimport type { IProjectRenderMeta } from '../extensions';\nimport { FileRegistry } from '../files/registry';\nimport { defaultExtensions } from '../languages/extensions';\nimport { defaultNameConflictResolvers } from '../languages/resolvers';\nimport type { Extensions, NameConflictResolvers } from '../languages/types';\nimport { NodeRegistry } from '../nodes/registry';\nimport type { IOutput } from '../output';\nimport { Planner } from '../planner/planner';\nimport { simpleNameConflictResolver } from '../planner/resolvers';\nimport type { NameConflictResolver } from '../planner/types';\nimport type { Renderer } from '../renderer';\nimport { SymbolRegistry } from '../symbols/registry';\nimport type { IProject } from './types';\n\nexport class Project implements IProject {\n  readonly files: FileRegistry;\n  readonly nodes = new NodeRegistry();\n  readonly symbols = new SymbolRegistry();\n\n  readonly defaultFileName: string;\n  readonly defaultNameConflictResolver: NameConflictResolver;\n  readonly extensions: Extensions;\n  readonly fileName?: (name: string) => string;\n  readonly nameConflictResolvers: NameConflictResolvers;\n  readonly renderers: ReadonlyArray<Renderer>;\n  readonly root: string;\n\n  constructor(\n    args: Pick<\n      Partial<IProject>,\n      | 'defaultFileName'\n      | 'defaultNameConflictResolver'\n      | 'extensions'\n      | 'fileName'\n      | 'nameConflictResolvers'\n      | 'renderers'\n    > &\n      Pick<IProject, 'root'>,\n  ) {\n    const fileName = args.fileName;\n    this.defaultFileName = args.defaultFileName ?? 'main';\n    this.defaultNameConflictResolver =\n      args.defaultNameConflictResolver ?? simpleNameConflictResolver;\n    this.extensions = {\n      ...defaultExtensions,\n      ...args.extensions,\n    };\n    this.fileName = typeof fileName === 'string' ? () => fileName : fileName;\n    this.files = new FileRegistry(this);\n    this.nameConflictResolvers = {\n      ...defaultNameConflictResolvers,\n      ...args.nameConflictResolvers,\n    };\n    this.renderers = args.renderers ?? [];\n    this.root = path.resolve(args.root).replace(/[/\\\\]+$/, '');\n  }\n\n  render(meta?: IProjectRenderMeta): ReadonlyArray<IOutput> {\n    new Planner(this).plan(meta);\n    const files: Array<IOutput> = [];\n    for (const file of this.files.registered()) {\n      if (file.finalPath && file.renderer) {\n        const content = file.renderer.render({ file, meta, project: this });\n        files.push({ content, path: file.finalPath });\n      }\n    }\n    return files;\n  }\n}\n"],"mappings":"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"}